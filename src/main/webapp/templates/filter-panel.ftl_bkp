
<style type="text/css">
    .xaxisid::-webkit-scrollbar {
        width: 0px;
    }
    .yaxisid::-webkit-scrollbar {
        width: 0px;
    }
    .nopadding {
        padding: 0 !important;
        margin: 0 !important;
    }
    .popupstackncontextview {
        max-height:568px;
        min-height: 568px;
        overflow: auto;
        color: black;
    }
    .popupstackpanel {
        max-height:538px;
        min-height: 538px;
    }
    .popupstackcontext {
        width: 100%;
        overflow: auto;
        font-size: 13px;
        height:538px;
    }
    .popuphackstak {
        width: 100%;
        font-size: 13px;
        max-height:507px;
        overflow: auto;
        color: black;
    }
    .strippedTable tr:nth-child(even){
        background-color : #ededed;
    }
    .stackncontextview {
        max-height:368px;
        min-height: 368px;
        overflow: auto;
        color: black;
    }
    .stackpanel {
        max-height:338px;
        min-height: 338px;
    }
    .stackcontext {
        width: 100%;
        overflow: auto;
        font-size: 11px;
        height:338px;
    }
    .hackstak {
        width: 100%;
        font-size: 11px;
        max-height:307px;
        overflow: auto;
        color: black;
    }
    .tgl:hover{
        fill: blue;
    }

    .requestHover{
        fill: blue;
    }
    .zoom {
        transition: transform .2s; /* Animation */
        margin: 0 auto;
    }
    .zoom:hover {
        transform: scale(1.5);
    }
    .rCell {
        background-color: #E21605;
    }
    .rsCell {
        background-color:#E5E6E7;
    }
    .stackCell {
        background-color:lightseagreen;
        height:10px;
        min-width:5px;
        border: 1px solid;
    }
    .socketCell {
        background-color:yellow;
        height:10px;
        min-width:5px;
        border: 1px solid;
    }
    .apexCell {
        background-color:deeppink;
        height:10px;
        min-width:5px;
        border: 1px solid;
    }
    .nativeCell {
        background-color:brown;
        height:10px;
        min-width:5px;
        border: 1px solid;
    }
    .jstackCell {
        background-color:dodgerblue;
        height:10px;
        min-width:5px;
        border: 1px solid;
    }
    .stackCells {
        background-color:black;
        height:12px;
        min-width:5px;
        border: 1px solid;
    }
    .filterinput {
        border: 1px solid #E5E6E7;
    }
    table.dataTable td,th {
        padding-left: 5px;
    }
    .statetable {
        overflow: auto;
    }
    div.dataTables_info {
        position: absolute
    }
    div.dataTables_paginate {
        float: left !important;
    }
    .dataTables_filter {
        float: left !important;
    }
    .toolbar {
        padding-bottom: 2px;
    }
    table.dataTable td {
        padding: 2px !important;
    }

    .popup {
        position: absolute;
        display: inline-block;
        cursor: pointer;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }

    /* The actual popup */
    .popup .popuptext {
        visibility: hidden;
        max-width: 1600px;
        max-height: 1600px;
        background-color: #555;
        color: #fff;
        text-align: left;
        border-radius: 6px;
        padding: 8px 0;
        position: absolute;
        z-index: 2;
        bottom: 125%;
        left: 50%;
        margin-left: 0px;
        padding: 5px;
    }

    /* Toggle this class - hide and show the popup */
    .popup .show {
        visibility: visible;
        -webkit-animation: fadeIn 1s;
        animation: fadeIn 1s;
    }

    /* Add animation (fade in the popup) */
    @-webkit-keyframes fadeIn {
        from {opacity: 0;}
        to {opacity: 1;}
    }

    @keyframes fadeIn {
        from {opacity: 0;}
        to {opacity:1 ;}
    }


    .cct-customized-scrollbar::-webkit-scrollbar {
        width: 8px;
        height: 8px;
        background-color: #E5E8E9; /* or add it to the track */
    }
    .cct-customized-scrollbar::-webkit-scrollbar-thumb {
        background: #6D6F70;
    }

</style>
<script type="text/javascript" class="init">
    let filterMap = {};
    $(function() {
        $.contextMenu({
            selector: '.context-menu-one',
            callback: function(key, options) {
                if(key  == "add") {
                    if($(this).attr("tp") == 3) {
                        addToFilter("req=" + $(this).text());
                        filterReq = $(this).attr("id");
                        filterStack = "";
                    }
                }else if(key == "show"){
                    showRequestContextPopup($(this).attr("id"));
                }
            },
            items: {
                "add": {name: "Add to filter"},
                "show": {name: "Show request
                timeline"}
            }
        });
        $.contextMenu({
            selector: '.context-menu-two',
            callback: function(key, options) {
                if(key  == "add") {
                    if($(this).attr("tp") == 3) {
                        addToFilter("req=" + $(this).text());
                        filterReq = $(this).attr("id");
                        filterStack = "";
                    }else if($(this).attr("tp") == 0) {
                        addToFilter("org=" + $(this).text());
                    }else if($(this).attr("tp") == 1) {
                        addToFilter("user=" + $(this).text());
                    }else if($(this).attr("tp") == 2) {
                        addToFilter("log=" + $(this).text());
                    }else if($(this).attr("tp") == 4) {
                        addToFilter("uri=" + $(this).text());
                    }else if($(this).attr("tp") == 6) {
                        addToFilter("tid=" + $(this).text());
                    }else if($(this).attr("tp") == 7) {
                        addToFilter("rac=" + $(this).text());
                    }else if($(this).attr("tp") == 8) {
                        addToFilter("thread_name=" + $(this).text());
                    }else if($(this).attr("tp") == 9) {
                        addToFilter("tier=" + $(this).text());
                    }else if($(this).attr("tp") == 10) {
                        addToFilter("sfdcmsgid=" + $(this).text());
                    }else if($(this).attr("tp") == 11) {
                        addToFilter("uri=" + $(this).text());
                    }
                }
            },
            items: {
                "add": {name: "Add to filter"}
            }
        });
    });

    function setApplyDisabled(shouldDisable) {
        $("#filter-apply").prop("disabled", shouldDisable);
    }
    function setResetDisabled(shouldDisable) {
        $("#filter-reset").prop("disabled", shouldDisable);
    }

    function addContextHint(hint, val){
        addToFilter(hint+"="+val);
        updateContextHintView(val);
    }

    function updateContextHintView(hintVal){
        if(hintVal == "all"){
            $('.all-heading').css({ 'font-weight': 'bold' });
            $('.sync-heading').css({ 'font-weight': 'normal' });
            $('.async-heading').css({ 'font-weight': 'normal' });
            $('.async-hints').removeClass('hide');
            $('.sync-hints').removeClass('hide');
            $('#filter-heading').text("Context hints");
        }else if(hintVal == "sync"){
            $('.all-heading').css({ 'font-weight': 'normal' });
            $('.sync-heading').css({ 'font-weight': 'bold' });
            $('.async-heading').css({ 'font-weight': 'normal' });
            $('.async-hints').addClass('hide');
            $('.sync-hints').removeClass('hide');
            $('#filter-heading').text("Sync context hints");
        }else if(hintVal == "async"){
            $('.all-heading').css({ 'font-weight': 'normal' });
            $('.sync-heading').css({ 'font-weight': 'normal' });
            $('.async-heading').css({ 'font-weight': 'bold' });
            $('.async-hints').removeClass('hide');
            $('.sync-hints').addClass('hide');
            $('#filter-heading').text("Async context hints");
        }
    }

    function resetContextHints(){
        let hintVal = "all";//default
        let array = filterBy.split(";");
        for(let i=0; i< array.length; i++){
            if(array[i] != "") {
                let pair = array[i].split("=");
                if(pair[0] == "context"){
                    hintVal = pair[1];
                }
            }
        }
        updateContextHintView(hintVal);
    }

    $(document).ready(function () {
        $("#queryfilter").on("change", (event) => {
            //validate manually edited filters
            $("#queryfilter").val($("#queryfilter").val().replace(/\s/g, ''));
            let array = $("#queryfilter").val().split(";");
            for(let i=0; i< array.length; i++){
                if(array[i] != "") {
                    let pair = array[i].split("=");
                    if(pair.length != 2) {
                        toastr_warning("Invalid filter(s) provided");
                        break;
                    }
                }
            }
            setApplyDisabled(false);
        });

        $("#filter-reset").on("click", (event) => {
            prevReqTid = "";
            prevReqTime = "";
            prevReqCellSid = "";
            prevReqCellTime = "";
            prevReqCellObj = null;

            $("#queryfilter").val("");
            filterBy = "";
            updateUrl("filterBy", "", true);
            filterReq = "";
            updateUrl("filterReq", "", true);
            filterStack = "";
            updateUrl("filterStack", "", true);
            filterFrame = "";
            frameFilterString = "";

            resetTreeInvertedLevel(FilterLevel.LEVEL1);
            resetTreeInvertedLevel(FilterLevel.LEVEL2);
            resetTreeInvertedLevel(FilterLevel.LEVEL3);

            resetTreeAllLevel(getActiveTree(getEventType(), false));
            enableRequestTimelineView(false);;

            //genRequestTable();
            $("#filter-apply").click();
        });

        $("#filter-apply").on("click", (event) => {
            if (filterStarted) {
                toastr_warning("Please wait for previous filter to finish.");
                return;
            }
            filterMap={};
            filterFrame = "";
            frameFilterString = "";
            let hasReqIDFilter = false;
            let array = $("#queryfilter").val().split(";");
            for(let i=0; i< array.length; i++){
                if(array[i] != "") {
                    let pair = array[i].split("=");
                    if(pair[0] == "frame") {
                        filterFrame = pair[1];
                        frameFilterString = pair[1];
                        //updateUrl("filterFrame", filterFrame, true);
                    }
                    if(pair[0] == "req") {
                        hasReqIDFilter = true;
                        if(filterReq == "" || filterReq == undefined){
                            //find matching request to show time line
                            findRequest(pair[1]);
                        }
                    }
                    filterMap[pair[0]] = pair[1];
                }
            }
            filterBy = $("#queryfilter").val();

            setApplyDisabled(true);
            if(filterBy == ""){
                setResetDisabled(true);
                updateContextHintView("all");
            }else {
                setResetDisabled(false);
            }

            updateUrl("filterBy", filterBy, true);
            if(hasReqIDFilter) {
                //updaate url with request timeline TO CHECK
                updateUrl("filterReq", filterReq, true);
                updateUrl("filterStack", filterStack, true);
            }else{
                //disable request timeline
                filterReq = "";
                filterStack = "";
                updateUrl("filterReq", "", true);
                updateUrl("filterStack", "", true);
                enableRequestTimelineView(false);
            }
            updateProfilerView(FilterLevel.LEVEL1);
        });

        filterBy=urlParams.get('filterBy') || '';
        filterReq=urlParams.get('filterReq') || '';
        filterStack=urlParams.get('filterStack') || '';
        filterStack=urlParams.get('filterStack') || '';
        contextTablePage = urlParams.get('cpage') || 0;
        customEvent = urlParams.get('customEvent') || 0;
        let tmpMultiSelect  = urlParams.get('mSelect') || '';

        setApplyDisabled(true);
        resetContextHints();
        if(filterBy == ""){
            setResetDisabled(true);
        }

        if(tmpMultiSelect !== undefined || tmpMultiSelect !== "") {
            let array = tmpMultiSelect.split(";");
            for(let i=0; i< array.length; i++){
                multiSelect[array[i]] = "selected";
            }
        }

        if(filterBy !== "" || filterBy !== undefined) {
            $("#queryfilter").val(filterBy);
            let array = filterBy.split(";");
            for(let i=0; i< array.length; i++){
                if(array[i] != "") {
                    let pair = array[i].split("=");
                    if(pair[0] == "frame"){
                        filterFrame = pair[1];
                        frameFilterString = pair[1];
                    }
                    filterMap[pair[0]]=pair[1];
                }
            }
        }

        contextTablePage = Number(contextTablePage);

        let str = "<table style=\"width: 100%;\" id=\"state-table\" class=\" \"><thead><tr><th><select style=\"border: 0px;\" class=\"\"  name=\"filtertable-input\" id=\"filtertable-input\"> <option value=\"org\">orgId</option> <option value=\"user\">userId</option> <option value=\"log\">logRecordType</option> <option value=\"reqId\">reqId</option> </select></th><th>cpuTime</th><th>runTime</th><th>gcTime</th><th><select style=\"border: 0px;\" class=\"\"  name=\"filtertable-input\" id=\"filtertable-input\"> <option value=\"org\">dbTime</option> <option value=\"user\">safepointTime</option> <option value=\"log\">apexTime</option> <option value=\"reqId\">dbCpu</option> </select></th></tr></thead>";
        str = str + "</table>";
        document.getElementById("statetable").innerHTML = str;
        $('#state-table').DataTable({
            "order": [[ 1, "desc" ]],
            searching: false,
            "columnDefs": [ {
                "targets": 0,
                "orderable": false
            } ],
            "sDom": '<"toolbar">frtip'
        });

        groupBy=urlParams.get('groupBy') || '';
        tableFormat=urlParams.get('tableFormat') || '0';
        sortBy=urlParams.get('sortBy') || '';

        sortBy=urlParams.get('sortBy') || '';
        cumulativeLine=urlParams.get('cumulative') || '0';
        $("#statetabledrp").html(getToolBarOptions());
        $("#filter-input").on("change", (event) => {
            genRequestTable();
        });
    });


    const FilterLevel = {
        LEVEL1: 1,
        LEVEL2: 2,
        LEVEL3: 3,
        UNDEFINED: 4
    };

    Object.freeze(FilterLevel);

    let treeHtml = "";
    // store the diff context trees so we don't have to make another call if we shift the foundation
    //1 for METHOD, 2 for SOCKET, 3 for APEX andd 4 for JSTACK, 5 for NATIVE
    let contextTree1 = {};
    let contextTree2 = {};

    let contextTreeInverted1 = {};
    let contextTreeInverted2 = {};

    let mergedContextTree = {};
    let mergedBacktraceTree = {};

    let queryStatus = {};

    let compareTree = false;
    let currentOption = 0;
    let isRefresh = true;
    let isLevelRefresh = true;
    let prevOption = 0;
    let isCalltree = false;
    const WARDEN_PROFILER = "Warden";
    let uploadIDMap = {};

    let contextData;
    let contextTree1Frames;
    let contextTree2Frames;
    let isJfrContext = false;
    let isS3 = "true";

    //1 for LEVEL1, 2 for LEVEL2 and 3 for LEVEL3

    let contextTree1InvertedLevel = {};


    /*let socketcontextTree1InvertedLevel = {1:undefined,2:undefined,3:undefined};
    let apexcontextTree1InvertedLevel = {1:undefined,2:undefined,3:undefined};
    let jstackcontextTree1InvertedLevel = {1:undefined,2:undefined,3:undefined};
    let nativecontextTree1InvertedLevel = {1:undefined,2:undefined,3:undefined};
    */


    let prevReqTid = "";
    let prevReqTime = "";

    let sortBy = "";
    let groupBy = "";
    let tableFormat = "";
    let cumulativeLine = "";
    let filterBy = "";
    let filterReq = "";
    let filterStack = "";
    let filterFrame = "";
    let filterEvent = 'jdk.ExecutionSample';
    let multiSelect = {};

    //one for LEVEL1, 2 for LEVEL2 and 3 for LEVEL3
    let contextInput = {1:{},2:{},3:{}};
    let filterStarted = false;
    let currentLoadedTree = null;

    let contextTable = undefined;
    let contextTablePage = 0;
    let customEvent = 0;

    let showTimeline = true;

    //one for LEVEL1, 2 for LEVEL2 and 3 for LEVEL3
    let filteredStackMap = {1:{},2:{},3:{}};

    let isTSView = false;

    function setTSView(bool){
        isTSView = bool;
    }

    function addToFilter(val) {
        let inppair = val.split("=");
        let array = $("#queryfilter").val().split(";");
        let tmpMap = {};
        for(let i=0; i< array.length; i++){
            array[i] = array[i].replace(/\s/g, '');
            if(array[i] != "") {
                let pair = array[i].split("=");
                if(pair[0] != inppair[0]){
                    tmpMap[pair[0]] = pair[1];
                }
            }
        }
        if(inppair[0] == "context" && inppair[1] == "all"){
            //skip
        }else {
            tmpMap[inppair[0]] = inppair[1];
        }
        let str = "";
        for(var key in tmpMap){
            str = str + key + "=" + tmpMap[key] + ";";
        }
        $("#queryfilter").val(str);
        setApplyDisabled(false);
    }

    $("#queryfilter").on("change", (event) => {
        alert(test);
        //validate manually edited filters
        $("#queryfilter").val($("#queryfilter").val().replace(/\s/g, ''));
        let array = $("#queryfilter").val().split(";");
        for(let i=0; i< array.length; i++){
            if(array[i] != "") {
                let pair = array[i].split("=");
                if(pair.length != 2) {
                    toastr_warning("Invalid filter(s) provided");
                    break;
                }
            }
        }
        setApplyDisabled(false);
    });

    function toggleView(directiton, view){
        if($("#"+directiton).hasClass("fa-chevron-up")){
            $("#"+directiton).removeClass("fa-chevron-up");
            $("#"+directiton).addClass("fa-chevron-down");
            $("#"+view).css("display","none");
            if(view == "logreq"){
                $("#stack").css("max-height","307px");
            }
        }else{
            $("#"+directiton).removeClass("fa-chevron-down");
            $("#"+directiton).addClass("fa-chevron-up");
            $("#"+view).css("display","block");
            if(view == "logreq"){
                $("#stack").css("max-height","275px");
            }
        }
    }

    function closeHelp(){
        $("#contexthelp").addClass("hide");
    }

    function showHelp(){
        $("#contexthelp").removeClass("hide");
    }

    function getFrameName(id) {
        if (isJfrContext == false) {
            return id;
        }
        if (contextTree1Frames[id] !== undefined) {
            return contextTree1Frames[id];
        } else if (contextTree2Frames !== undefined && contextTree2Frames[id] !== undefined) {
            return contextTree2Frames[id];
        }
        return "id:"+id;
    }

    function onLevel3Filter() {
        if (filterFrame !== undefined && filterFrame != "") {
            updateStackIndex(getActiveTree(getEventType(), false));
            isLevelRefresh = true;
            filterTree(getActiveTree(getEventType(), false));
            if (getSelectedLevel(getActiveTree(getEventType(), false)) !== FilterLevel.LEVEL3) {
                getActiveTree(getEventType(), false)[FilterLevel.LEVEL3] = 0;
            }
        }
    }

    function onLevel2Filter() {
        if (filterReq !== undefined && filterReq != "") {
            let pair = filterReq.split("_");

            updateStackIndex(getActiveTree(getEventType(), false));//need this as stacks identified based on index
            isLevelRefresh = true;
            showRequestTimelineView(pair[0], pair[1], true);

            if (getSelectedLevel(getActiveTree(getEventType(), false)) !== FilterLevel.LEVEL2) {
                getActiveTree(getEventType(), false)[FilterLevel.LEVEL2] = 0;
            }
        }
    }

    function updateRequestView() {
        console.log("updateRequestView");
        if (filterReq !== undefined && filterReq != "") {
            let pair = filterReq.split("_");
            if ($("#" + filterReq).length != 0 && !$("#" + filterReq).hasClass("rsCell")) {
                $("#" + filterReq).addClass("rsCell");
                $("#" + filterReq).removeClass("rCell");
                prevReqTid = pair[0];
                prevReqTime = pair[1];

                if (filterStack !== undefined && filterStack != "") {
                    enableRequestTimelineView(true);
                    let stackPair = filterStack.split("_");
                    if ($("#" + stackPair[0] + "-" + stackPair[1]).length != 0 && !$("#" + stackPair[0] + "-" + stackPair[1]).hasClass('stackCells')) {
                        $("#" + stackPair[0] + "-" + stackPair[1]).click();
                    }
                }
            }
        }
    }

    function onLevel1Filter() {
        if (filterMap["tid"] == undefined && isFilterEmpty()) {
            //genRequestTable();
        } else {
            //genRequestTable();
            updateStackIndex(getActiveTree(getEventType(), false));//need this as stacks identified based on index
            isLevelRefresh = true;
            filterOnType();
            if (getSelectedLevel(getActiveTree(getEventType(), false)) !== FilterLevel.LEVEL1) {
                getActiveTree(getEventType(), false)[FilterLevel.LEVEL1] = 0;
            }
        }
    }

    let tableUpdateInput = "";

    function getLevel1FilterInput() {
        let str = "";
        let array = filterBy.split(";");
        for(let i=0; i< array.length; i++){
            if(array[i] != "") {
                let pair = array[i].split("=");
                if(pair[0] != "frame") { //frame is a second level filter
                    str = str + pair[0] + "=" + pair[1] + ";";
                }
            }
        }
        return str;
    }

    function filterToLevel(level) {
        let eventType = getEventType();
        if (contextData === undefined || isJfrContext == false) {
            return true;
        }
        if (filterStarted) {
            toastr_warning("Please wait for previous filter to finish.");
            return false;
        }
        filterStarted = true;

        let updateContextTable = false;

        try {
            if (level == FilterLevel.LEVEL1) {
                let level1InputTmp = getLevel1FilterInput();
                if (level1InputTmp !== contextInput[FilterLevel.LEVEL1][eventType]) {
                    contextInput[FilterLevel.LEVEL1][eventType] = level1InputTmp;
                    //level1  filter
                    //clean off level 2 history
                    prevReqTid = "";
                    prevReqTime = "";
                    document.getElementById("stack").innerHTML = "";
                    resetTreeLevel(getActiveTree(eventType, false), FilterLevel.LEVEL1);
                    resetTreeInvertedLevel(FilterLevel.LEVEL1);
                    resetTreeLevel(getActiveTree(eventType, false), FilterLevel.LEVEL2);
                    resetTreeInvertedLevel(FilterLevel.LEVEL2);
                    resetTreeLevel(getActiveTree(eventType, false), FilterLevel.LEVEL3);
                    resetTreeInvertedLevel(FilterLevel.LEVEL3);

                    onLevel1Filter();
                    updateContextTable=true;
                }
            }

            if (level == FilterLevel.LEVEL2 || level == FilterLevel.LEVEL1) {
                let level2InputTmp = filterBy + filterReq + filterStack;
                if (level2InputTmp !== contextInput[FilterLevel.LEVEL2][eventType]) {
                    contextInput[FilterLevel.LEVEL2][eventType] = level2InputTmp;
                    document.getElementById("stack").innerHTML = "";
                    document.getElementById("stackcontext").innerHTML = "";
                    document.getElementById("threadstate").innerHTML = "";
                    //clean off sub level history
                    prevReqCellSid = "";
                    prevReqCellTime = "";
                    prevReqCellObj = null;
                    resetTreeLevel(getActiveTree(eventType, false), FilterLevel.LEVEL2);
                    resetTreeInvertedLevel(FilterLevel.LEVEL2);
                    resetTreeLevel(getActiveTree(eventType, false), FilterLevel.LEVEL3);
                    resetTreeInvertedLevel(FilterLevel.LEVEL3);
                    onLevel2Filter();
                }
            }

            if (level == FilterLevel.LEVEL3 || level == FilterLevel.LEVEL2 || level == FilterLevel.LEVEL1) {
                let level3InputTmp = filterBy + filterReq + filterStack + filterFrame;

                if (level3InputTmp !== contextInput[FilterLevel.LEVEL3][eventType]) {
                    contextInput[FilterLevel.LEVEL3][eventType] = level3InputTmp;
                    resetTreeLevel(getActiveTree(eventType, false), FilterLevel.LEVEL3);
                    resetTreeInvertedLevel(FilterLevel.LEVEL3);
                    onLevel3Filter();
                    updateContextTable = true;
                }
            }

            if(updateContextTable){
                genRequestTable();
            }

            updateRequestView();

            if (isCalltree) {
                if (getSelectedLevel(getActiveTree(eventType, false)) === FilterLevel.UNDEFINED) {
                    if (getContextTreeInverted(1, eventType) === undefined) {
                        setContextTreeInverted(invertTreeV1(getContextTree(1, eventType), 1), 1, eventType);
                    }
                } else if (getcontextTree1InvertedLevel(eventType, getSelectedLevel(getActiveTree(eventType, false))) === undefined) {
                    setcontextTree1InvertedLevel(invertTreeV1AtLevel(getActiveTree(eventType, false), 1), eventType, getSelectedLevel(getActiveTree(eventType, false)));
                }
            }
            filterStarted = false;

        } catch (err) {
            filterStarted = false;
            console.log("FilterToLevel Exception:" + err + " " + err.stack);

            return false;
        }
        return true;
    }



    function resetTreeInvertedLevel(level) {
        for (var key in jfrevents1) {
            setcontextTree1InvertedLevel(undefined, key, level);
        }
    }

    function resetTreeLevel(tree, level) {
        if (tree[level] !== undefined) {
            tree[level] = undefined;
        }
        let ch = tree['ch'];

        if (ch != undefined && ch !== null) {
            for (let index = 0; index < ch.length; index++) {
                resetTreeLevel(ch[index], level);
            }
        }
    }

    function resetTreeAllLevel(tree) {
        if (tree[FilterLevel.LEVEL1] !== undefined) {
            tree[FilterLevel.LEVEL1] = undefined;
        }
        if (tree[FilterLevel.LEVEL2] !== undefined) {
            tree[FilterLevel.LEVEL2] = undefined;
        }
        if (tree[FilterLevel.LEVEL3] !== undefined) {
            tree[FilterLevel.LEVEL3] = undefined;
        }
        let ch = tree['ch'];
        if (ch != undefined && ch !== null) {
            for (let index = 0; index < ch.length; index++) {
                resetTreeAllLevel(ch[index]);
            }
        }
    }

    function applyFilter(){
        $("#filter-apply").click();
    }




    function findRequest(reqId){
        if (contextData !== undefined) {
            var BreakException = {};
            try {
                //contextData.tidlist.forEach(function (tid) {
                for(var tid in contextData.records) {
                    contextData.records[tid].forEach(function (obj) {
                        if(obj.type == 2 || obj.type == 6) {//do not include sub requests
                            if (obj.reqId !== undefined && obj.reqId == reqId) {
                                filterReq = obj.tid + "_" + obj.epoch;
                                throw BreakException;
                            }
                        }
                    });
                }
                //});
            } catch (e) {
                if (e !== BreakException) throw e;
            }
        }
    }

    function showTimelineView(opt){
        showTimeline = opt;
    }

    function enableRequestTimelineView(opt){
        if(showTimeline && opt){
            $("#stackncontextview").removeClass("hide");
        }else{
            document.getElementById("timelinetitle").innerHTML = "";
            $("#stackncontextview").addClass("hide");
        }
    }

    let frameFilterString = "";

    function filterTree(tree) {
        if (frameFilterString !== undefined && frameFilterString.length != 0) {
            if (tree['tree'] !== undefined) {
                tree = tree['tree'];
            }
            let level = getSelectedLevel(getActiveTree(getEventType(), false));
            frameFilterStackMap[getEventType()] = {};
            filterFramesV1Level(tree, false, level);
        }
    }

    function sortTreeLevelBySize(tree, level) {
        let ch = tree['ch'];
        if (ch != undefined && ch !== null) {
            for (let index = 0; index < ch.length; index++) {
                sortTreeLevelBySize(ch[index], level);
            }
            ch.sort(function (a, b) {
                if (b[level] !== undefined && a[level] !== undefined) {
                    return b[level] - a[level];
                } else if (b[level] !== undefined) {
                    return b[level];
                } else if (a[level] !== undefined) {
                    return 0 - a[level];
                } else {
                    return 0;
                }
            });
        }
    }

    let prevReqCellSid = "";
    let prevReqCellTime = "";
    let prevReqCellObj = null;

    function getStackTrace(stackid){
        let eventType = getEventType();

        let sampleType = eventType;

        let stacktrace = "";
        let tmpcontextTree1Level1 = getStackFrameV1("root");
        let tmpActiveTree = getActiveTree(eventType, false);
        //if (tmpActiveTree.treeIndex !== undefined && tmpActiveTree.treeIndex !== FilterLevel.LEVEL2) {
        updateStackIndex(tmpActiveTree); //at this point tree must be indexed on LEVEL2
        //}

        let arr = getTreeStack(tmpActiveTree, stackid, tmpcontextTree1Level1, 1);
        let ch = tmpcontextTree1Level1.ch;
        stacktrace = stacktrace + sampleType + "\n\n";
        while (ch !== undefined && ch != null && ch.length == 1) {
            stacktrace = stacktrace  + getFrameName(ch[0].nm) + "\n";
            ch = ch[0].ch;
        }
        return stacktrace;
    }
    function showStack(stackid, time, eventType, obj) {
        if (prevReqCellSid == stackid && prevReqCellTime == time) {
            updateUrl("filterStack", "");
            document.getElementById("stack").innerHTML = "";
            prevReqCellSid = "";
            prevReqCellTime = "";
            prevReqCellObj = null;
            filterStack = "";

            if ($("#" + stackid + "-" + time).length != 0) {
                //$("#" + stackid + "-" + time).addClass("stackCell");
                $("#" + stackid + "-" + time).removeClass("stackCells");
            }
        } else {
            updateUrl("filterStack", stackid + "_" + time);
            filterStack = stackid + "_" + time;
            document.getElementById("stack").innerHTML = "";
            if ($("#" + prevReqCellSid + "-" + prevReqCellTime).length != 0) {
                //$("#" + prevReqCellSid + "-" + prevReqCellTime).addClass("stackCell");
                $("#" + prevReqCellSid + "-" + prevReqCellTime).removeClass("stackCells");
            }

            if ($("#" + stackid + "-" + time).length != 0) {
                $("#" + stackid + "-" + time).addClass("stackCells");
                //$("#" + stackid + "-" + time).removeClass("stackCell");
            }

            prevReqCellObj = obj;
            prevReqCellSid = stackid;
            prevReqCellTime = time;

            let sampleType = eventType;

            let stacktrace = "<table  style=\"border: 0px;\">";
            let tmpcontextTree1Level1 = getStackFrameV1("root");
            let tmpActiveTree = getActiveTree(eventType, false);
            //if (tmpActiveTree.treeIndex !== undefined && tmpActiveTree.treeIndex !== FilterLevel.LEVEL2) {
            updateStackIndex(tmpActiveTree); //at this point tree must be indexed on LEVEL2
            //}

            let arr = getTreeStack(tmpActiveTree, stackid, tmpcontextTree1Level1, 1);
            let ch = tmpcontextTree1Level1.ch;
            stacktrace = stacktrace + "<tr><td>" + moment.utc(time).format('YYYY-MM-DD HH:mm:ss.SSS') + " - " + sampleType + "<p></p></td></tr>";
            while (ch !== undefined && ch != null && ch.length == 1) {
                stacktrace = stacktrace + "<tr><td>" + getFrameName(ch[0].nm) + "</td></tr>";
                ch = ch[0].ch;
            }
            stacktrace = stacktrace + "</table>";
            document.getElementById("stack").innerHTML = stacktrace;
        }
    }


    let prevpopReqCellSid = "";
    let prevpopReqCellTime = "";
    let prevpopReqCellObj = null;

    function showpopStack(stackid, time, eventType, obj) {
        if (prevpopReqCellSid == stackid && prevpopReqCellTime == time) {
            //updateUrl("filterStack", "");
            document.getElementById("popupstack").innerHTML = "";
            prevpopReqCellSid = "";
            prevpopReqCellTime = "";
            prevpopReqCellObj = null;
            popfilterStack = "";

            if ($("#" + stackid + "-" + time+"_pop").length != 0) {
                //$("#" + stackid + "-" + time+"_pop").addClass("stackCell");
                $("#" + stackid + "-" + time+"_pop").removeClass("stackCells");
            }
        } else {
            //updateUrl("filterStack", stackid + "_" + time);
            popfilterStack = stackid + "_" + time+"_pop";
            document.getElementById("popupstack").innerHTML = "";
            if ($("#" + prevpopReqCellSid + "-" + prevpopReqCellTime+"_pop").length != 0) {
                //$("#" + prevpopReqCellSid + "-" + prevpopReqCellTime+"_pop").addClass("stackCell");
                $("#" + prevpopReqCellSid + "-" + prevpopReqCellTime+"_pop").removeClass("stackCells");
            }

            if ($("#" + stackid + "-" + time+"_pop").length != 0) {
                $("#" + stackid + "-" + time+"_pop").addClass("stackCells");
                //$("#" + stackid + "-" + time+"_pop").removeClass("stackCell");
            }

            prevpopReqCellObj = obj;
            prevpopReqCellSid = stackid;
            prevpopReqCellTime = time;

            let sampleType = eventType;

            let stacktrace = "<table  style=\"border: 0px;\">";
            let tmpcontextTree1Level1 = getStackFrameV1("root");
            let tmpActiveTree = getActiveTree(eventType, false);
            //if (tmpActiveTree.treeIndex !== undefined && tmpActiveTree.treeIndex !== FilterLevel.LEVEL2) {
            updateStackIndex(tmpActiveTree); //at this point tree must be indexed on LEVEL2
            //}

            let arr = getTreeStack(tmpActiveTree, stackid, tmpcontextTree1Level1, 1);
            let ch = tmpcontextTree1Level1.ch;
            stacktrace = stacktrace + "<tr><td>" + moment.utc(time).format('YYYY-MM-DD HH:mm:ss.SSS') + " - " + sampleType + "<p></p></td></tr>";
            while (ch !== undefined && ch != null && ch.length == 1) {
                stacktrace = stacktrace + "<tr><td>" + getFrameName(ch[0].nm) + "</td></tr>";
                ch = ch[0].ch;
            }
            stacktrace = stacktrace + "</table>";
            document.getElementById("popupstack").innerHTML = stacktrace;
        }
    }

    function frameFilter() {
        if (filterStarted) {
            toastr_warning("Please wait for previous filter to finish.");
            return;
        }
        updateProfilerView(FilterLevel.LEVEL3);
    }

    function hideFilterViewStatus(){
        $("#filter-view-status").addClass("hide");
    }
    function unhideFilterViewStatus(){
        $("#filter-view-status").removeClass("hide");
    }
    function updateFilterViewStatus(status){
        document.getElementById("filter-view-status").innerHTML = status;
    }
    function showContextFilter(){
        $("#contextpanel").removeClass("hide");
    }

    function isinRequest(arr, start, end) {
        let l = 0, r = arr.length - 1;
        while (l <= r) {
            let m = Math.floor((l + r) / 2);
            if (arr[m].time >= start && arr[m].time <= end)
                return m;
            else if (arr[m].time > end)
                r = m - 1;
            else
                l = m + 1;
        }
        return -1;
    }

    function logColor(line) {
        if(line == "U"){
            return "#DA823B";
        }else if(line == "5") {
            return "#925EB0";
        }else if(line == "4") {
            return "#5098D5";
        }else {
            return "#828282";
        }
    }

    let curStackIDT = undefined;
    let curLevelT = undefined;
    let curSizeT = undefined;

    function getTreeStackLevel(tree, stackid, size, level) {
        if (tree['tree'] !== undefined) {
            tree = tree['tree'];
        }
        if (tree.sm[stackid] !== undefined && tree.ch[tree.sm[stackid]].sm[stackid] !== undefined) {

            curStackIDT = stackid;
            curLevelT = level;
            curSizeT = size;

            if (getStackLevel(tree.ch[tree.sm[stackid]], 0)) {
                if (tree[level] !== undefined) {
                    tree[level] = tree[level] + size;
                } else {
                    tree[level] = size;
                }
            }
        }
    }

    function getTreeStack(tree, stackid, filterTree, size) {
        if (tree['tree'] !== undefined) {
            tree = tree['tree'];
        }
        if (tree.sm[stackid] != undefined && tree.ch[tree.sm[stackid]].sm[stackid] !== undefined) {

            let bseJsonTree = tree.ch[tree.sm[stackid]];
            //handle single frame case
            if(bseJsonTree['ch'] == null || bseJsonTree['ch'].length == 0){
                addFrameV1(bseJsonTree['nm'], size, size, filterTree);
                return;
            }else {
                let arr = [];
                let res = getStack(tree.ch[tree.sm[stackid]], filterTree, arr, size, stackid, false);
                return res;
            }
        }
    }

    function resetTree(baseJsonTree) {
        if (baseJsonTree['tree'] !== undefined) {
            baseJsonTree = baseJsonTree['tree'];
        }
        if (baseJsonTree['1'] !== undefined) {
            baseJsonTree['1'] = 0;
        }
        if (baseJsonTree['2'] !== undefined) {
            baseJsonTree['2'] = 0;
        }
        if (baseJsonTree['3'] !== undefined) {
            baseJsonTree['3'] = 0;
        }
        for (let treeIndex = 0; treeIndex < baseJsonTree['ch'].length; treeIndex++) {
            resetTree(baseJsonTree['ch'][treeIndex]);
        }
    }

    function getStackLevel(baseJsonTree, depth) {

        if (depth != 0 && baseJsonTree.sm[curStackIDT] !== undefined && baseJsonTree.sm[curStackIDT] === 1) {

            if (baseJsonTree[curLevelT] !== undefined) {
                baseJsonTree[curLevelT] = baseJsonTree[curLevelT] + curSizeT;
            } else {
                baseJsonTree[curLevelT] = curSizeT;
            }
            return true;
        }

        if (baseJsonTree['ch'] == null || baseJsonTree['ch'].length == 0) {
            return false;
        }

        let found = false;
        if (isCalltree && baseJsonTree.hash !== undefined && baseJsonTree.hash[curStackIDT] !== undefined) {
            let res = getStackLevel(baseJsonTree['ch'][baseJsonTree.hash[curStackIDT]], depth + 1);
            if (res === true) {
                found = true;
            }
        } else {
            for (let treeIndex = 0; treeIndex < baseJsonTree['ch'].length; treeIndex++) {
                let res = getStackLevel(baseJsonTree['ch'][treeIndex], depth + 1);
                if (res === true) {
                    found = true;
                    break; // break loop, stack already found
                }
            }
        }
        if (found === true) {
            if (baseJsonTree[curLevelT] !== undefined) {
                baseJsonTree[curLevelT] = baseJsonTree[curLevelT] + curSizeT;
            } else {
                baseJsonTree[curLevelT] = curSizeT;
            }
        }
        return found;
    }

    function getStack(baseJsonTree, filterTree, arr, size, stackid, flag) {
        if (baseJsonTree['ch'] == null || baseJsonTree['ch'].length == 0) {
            let tmparr = [...arr];
            tmparr.push(baseJsonTree['nm']);
            if (flag && baseJsonTree.sm[stackid] !== undefined) {
                let frame = filterTree;
                let tmparr = [...arr];
                tmparr.push(baseJsonTree['nm']);
                for (let i = 0; i < tmparr.length; i++) {
                    if (i == tmparr.length - 1) {
                        frame = addFrameV1(tmparr[i], size, size, frame);
                    } else {
                        frame = addFrameV1(tmparr[i], size, 0, frame);
                    }
                }
            }
            return;
        } else {
            for (let treeIndex = 0; treeIndex < baseJsonTree['ch'].length; treeIndex++) {
                let tmparr = [...arr];
                tmparr.push(baseJsonTree['nm']);
                getStack(baseJsonTree['ch'][treeIndex], filterTree, tmparr, size, stackid, true)
            }
            if (flag && baseJsonTree.sm[stackid] !== undefined) {
                let frame = filterTree;
                let tmparr = [...arr];
                tmparr.push(baseJsonTree['nm']);
                for (let i = 0; i < tmparr.length; i++) {
                    if (i == tmparr.length - 1) {
                        frame = addFrameV1(tmparr[i], size, size, frame);
                    } else {
                        frame = addFrameV1(tmparr[i], size, 0, frame);
                    }
                }
            }
            return;
        }
    }

    let frameFilterStackMap = {1:undefined,2:undefined,3:undefined,4:undefined};

    function filterFramesV1Level(baseJsonTree, include, level) {
        if (baseJsonTree == null) {//safety check
            return 0;
        }
        if (level != FilterLevel.UNDEFINED && baseJsonTree[level] === undefined) {
            return 0;
        }

        let count = 0;
        let curInclude = false;
        let event = getEventType();
        if (!include) {
            //check if current frame contains filter string
            if (baseJsonTree !== null && getFrameName(baseJsonTree['nm']) !== undefined && getFrameName(baseJsonTree['nm']).includes(frameFilterString)) {
                if (level != FilterLevel.UNDEFINED) {
                    count = baseJsonTree[level];
                } else {
                    count = baseJsonTree['sz'];
                }
                include = true;
                curInclude = true;
            }
        }

        if (include) {
            //either current or parent included
            if (level != FilterLevel.UNDEFINED) {
                baseJsonTree[FilterLevel.LEVEL3] = baseJsonTree[level];
            } else {
                baseJsonTree[FilterLevel.LEVEL3] = baseJsonTree['sz'];
            }
        } else {
            if (baseJsonTree[FilterLevel.LEVEL3] !== undefined) {
                baseJsonTree[FilterLevel.LEVEL3] = undefined;
            }
        }

        let chCount = 0;
        if (baseJsonTree['ch'] != null) {
            //search filter string in all sub nodes
            for (let treeIndex = 0; treeIndex < baseJsonTree['ch'].length; treeIndex++) {
                if (level != FilterLevel.UNDEFINED && baseJsonTree['ch'][treeIndex][level] === undefined) {
                    continue;
                }
                chCount = chCount + filterFramesV1Level(baseJsonTree['ch'][treeIndex], include, level);
            }
        }else{
            if(curInclude || include) {
                //collect stacks included in frame filter
                if(baseJsonTree.sm !== undefined) {
                    for (var key in baseJsonTree.sm) {
                        frameFilterStackMap[event][key] = 1;
                    }
                }
            }
        }

        if (curInclude) {
            //let parent know the number of stacks count included
            return count;
        } else if (include) {
            //parent included, return is just ignored
            return 0;
        } else {
            if (chCount > 0) {
                //none of parents or this frame contains filter string, but children has filter string so include the occurrence count
                baseJsonTree[FilterLevel.LEVEL3] = chCount;
            }
            //let parent know that the children found filter string and count
            return chCount;
        }
    }

    function showRequestContextPopup(filterReq){
        if(filterReq != undefined) {
            popfilterStack = "";
            createTimelineModal("timelinepopup");
            loadModal("timelinepopup");
            setTimeout(function () {
                $('#timelinepopup').focus();
                let pair = filterReq.split("_");
                showRequestTimelineView(pair[0],pair[1],false);
                let stackPair = popfilterStack.split("_");
                if ($("#" + stackPair[0] + "-" + stackPair[1]+"_pop").length != 0 && !$("#" + stackPair[0] + "-" + stackPair[1]+"_pop").hasClass("stackCells")) {
                    $("#" + stackPair[0] + "-" + stackPair[1]+"_pop").click();
                }
            }, 500);
        }
    }

    function createTimelineModal(modalId) {
        $('#modals-guid')[0].innerHTML = "<div  class='modal inmodal fade' data-backdrop=\"static\"  id='" + modalId + "' tabindex='-1' role='dialog'  aria-hidden='true'>\n" +
            "    <div style=\"width: 95%; horizontal-align:middle;\" class='modal-dialog'>\n" +
            "        <div class='modal-content'>\n" +
            "           <div style=\"float: right;\"><i onClick=\"unLoadModal('"+modalId+"');\" style='cursor: pointer'>X&nbsp;&nbsp;</i>" +
            "           </div>" +
            "           <div id='data-modal-body' class='modal-body' style='overflow: auto'> <ul class=\"tree\"><li>\n" +
            "<div id=\"popupstackncontextview\"  style=\"padding-top: 5px; padding-left: 0px;padding-right: 0px;\" class=\"popupstackncontextview col-lg-12\" >\n" +
            "<span id=\"timelinepopuptitle\" style=\"color: #686A6C;font-family: 'Arial', serif;\">Profiling samples collected during request runTime</span>\n" +
            "<div style=\"padding-top:0px; padding-left: 0px;padding-right: 0px;\" class=\"col-lg-12\">\n" +
            "<div style=\"padding-top: 0px; padding-left: 0px;padding-right: 5px;padding-bottom: 5px;\" class=\"popupfilterpanel col-lg-9\">\n" +
            "<div style=\"border-color: #e5e6e7;  border-width: 1px; border-style: solid;padding-top: 3px; padding-left: 5px;padding-right: 5px;\" class=\"popupstackpanel\">\n" +
            "<div style=\"overflow: auto;\" class=\"cct-customized-scrollbar popupthreadstate\" id=\"popupthreadstate\">\n" +
            "</div>\n" +
            "<div class=\"popuphackstak\" id=\"popupstack\">\n" +
            "</div>\n" +
            "</div>\n" +
            "</div>\n" +
            "<div class=\"nopadding col-lg-3\">\n" +
            "<div  style=\"border-color: #e5e6e7;  border-width: 1px; border-style: solid; padding: 5px;\"  class=\"popupstackcontext\" id=\"popupstackcontext\">\n" +
            "</div>\n" +
            "</div>\n" +
            "</div>\n" +
            "</div>\n" +
            "            </ul></div>\n" +
            "        </div>\n" +
            "    </div>\n" +
            "</div>";
    }

    function loadModal(modalId) {
        $('#' + modalId).modal('show');
    }

    function unLoadModal(modalId) {
        $('#'+modalId).modal('hide');
        prevpopReqCellObj=null;
        prevReqCellObj=null;
    }

    let clickC = 0;

    document.onkeydown = function (evt) {
        evt = evt || window.event;

        const timelinepopupmodalElement = document.getElementById("timelinepopup");
        const timelineElement = document.getElementById("stackncontextview");

        if (timelinepopupmodalElement !== null && timelinepopupmodalElement.style.display !== "none") {
            console.log("timelinepopup active " + clickC+ ":" +evt.keyCode);
            if (evt.keyCode == 39) {
                nextAvailablepopStack();
            } else if (evt.keyCode == 37) {
                previousAvailablepopStack();
            }else if (evt.keyCode == 27) {
                prevpopReqCellObj=null;
            }
            clickC++;
        }else if (timelineElement !== null && timelineElement.style.display !== "none") {
            console.log("stackncontextview active " + clickC + ":" +evt.keyCode);
            if (evt.keyCode == 39) {
                nextAvailableStack();
            } else if (evt.keyCode == 37) {
                previousAvailableStack();
            }
            clickC++;
        }
        actViewKeyDown(evt);
    };

    function nextAvailablepopStack() {
        var cur = prevpopReqCellObj;
        while (cur != null && cur.nextSibling != null) {
            cur = cur.nextSibling;
            if(!cur.classList.contains('hide')) {
                cur.click();
                break;
            }
        }
    }

    function previousAvailablepopStack() {
        var cur = prevpopReqCellObj;
        while (cur != null && cur.previousSibling != null) {
            cur = cur.previousSibling;
            if(!cur.classList.contains('hide')) {
                cur.click();
                break;
            }
        }
    }

    function nextAvailableStack() {
        var cur = prevReqCellObj;
        while (cur != null && cur.nextSibling != null) {
            cur = cur.nextSibling;
            if(!cur.classList.contains('hide')) {
                cur.click();
                break;
            }
        }
    }

    function previousAvailableStack() {
        var cur = prevReqCellObj;
        while (cur != null && cur.previousSibling != null) {
            cur = cur.previousSibling;
            if(!cur.classList.contains('hide')) {
                cur.click();
                break;
            }
        }
    }

    function addClickActionsToFilterTable(tableid) {
        var t = document.getElementById(tableid);
        for (var r = 0; r < t.rows.length; r++) {
            for (var c = 0; c < t.rows[r].cells.length; c++) {
                t.rows[r].cells[c].addEventListener('click', function (e) {
                    if (e.altKey) {
                        if($(e.target).attr("tp") == 3) {
                            addToFilter("req=" + $(e.target).html());
                            filterReq = $(e.target).attr("id");
                            filterStack = "";
                        }else if($(e.target).attr("tp") == 0) {
                            addToFilter("org=" + $(e.target).html());
                        }else if($(e.target).attr("tp") == 1) {
                            addToFilter("user=" + $(e.target).html());
                        }else if($(e.target).attr("tp") == 2) {
                            addToFilter("log=" + $(e.target).html());
                        }else if($(e.target).attr("tp") == 4) {
                            addToFilter("uri=" + $(e.target).html());
                        }else if($(e.target).attr("tp") == 6) {
                            addToFilter("tid=" + $(e.target).html());
                        }else if($(e.target).attr("tp") == 7) {
                            addToFilter("rac=" + $(e.target).html());
                        }else if($(e.target).attr("tp") == 8) {
                            addToFilter("thread_name=" + $(e.target).html());
                        }
                    }else{
                        if($(e.target).attr("tp") == 3) {
                            //showRequestContextPopup($(e.target).attr("id")); //click show request timeline
                        }
                    }
                });
                t.rows[r].cells[c].addEventListener('mouseleave', function (e) {
                    if($(e.target).attr("tp") == 3) {
                        var popup = document.getElementById("idPopup");
                        popup.classList.remove("show");
                    }
                });
            }
        }
    }

    function getContextView(obj) {
        let str = "";
        if (obj.type == 2) {
            str = str + "<tr>" +
                "<td style=\"white-space: nowrap;\" title='start time of the request'>date</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + moment.utc(obj.epoch).format('YYYY-MM-DD HH:mm:ss SSS') + "</td></tr>" +
                "<tr><td  style=\"white-space: nowrap;\" title='organization Id'>orgId</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.orgId + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='user Id'>userId</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.userId + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='the wall time in ms this request took (APT)'>runTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.runTime + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='the amount of cpu time in ms this request took'>cpuTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.cpuTime + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='GC duraiton in ms that impacted this request'>gcTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.gcTime + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='log record type associated with the request'>logRecordType</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.logType + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='rac node'>racNode</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.racNode + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='thread Id'>tid</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.tid + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='request Id'>reqId</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.reqId + "</td></tr>";
            if (obj.trust !== undefined) {
                str = str + "<tr><td style=\"white-space: nowrap;\" title='time spent in database'>dbTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.dbTime + "</td></tr>" +
                    "<tr><td style=\"white-space: nowrap;\" title='time spent waiting for and including a safepoint'>safepointTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.spTime + "</td></tr>" +
                    "<tr><td style=\"white-space: nowrap;\" title='approximate accumulated time ms that the thread waited for notification'>waitTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.waitTime + "</td></tr>" +
                    "<tr><td style=\"white-space: nowrap;\" title='approximate accumulated time ms that the thread blocked to enter/reenter a monitor'>blockedTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.blockTime + "</td></tr>" +
                    "<tr><td style=\"white-space: nowrap;\" title='wall clock time ms spent in apex code'>apexTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.apexTime + "</td></tr>" +
                    "<tr><td style=\"white-space: nowrap;\" title='wall clock time ms spent in apex call out'>apexCalloutTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.apexCoTime + "</td></tr>" +
                    "<tr><td style=\"white-space: nowrap;\" title='time ms spent in accessing cached resources'>cacheTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.cacheTime + "</td></tr>" +
                    "<tr><td style=\"white-space: nowrap;\" title='log name of the request'>uri</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.ln + "</td></tr>" +
                    "<tr><td style=\"white-space: nowrap;\" title='is this a trust request'>trust</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.trust + "</td></tr>";
            }
            if (obj.gets !== undefined) {
                str = str + "<tr><td style=\"white-space: nowrap;\" title='time spent ms in db'>oraDbTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.odbTime + "</td></tr>" +
                    "<tr><td style=\"white-space: nowrap;\" title='cpu time ms in db'>dbCpu</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.dbCpu + "</td></tr>" +
                    "<tr><td style=\"white-space: nowrap;\" title='number of physical reads in db'>physRead</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.pRead + "</td></tr>" +
                    "<tr><td style=\"white-space: nowrap;\" title='number of physical writes in db'>physWrite</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.pWrite + "</td></tr>" +
                    "<tr><td style=\"white-space: nowrap;\" title='time ms for which the connection was checkedout from the pool'>dbConChkOut</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.dbCCT + "</td></tr>" +
                    "<tr><td style=\"white-space: nowrap;\" title='time ms taken to acquire a db connection or hit the timout'>dbGetCon</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.dbGetc + "</td></tr>" +
                    "<tr><td style=\"white-space: nowrap;\" title='number of buffer gets in db'>gets</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.gets + "</td></tr>";
            }
        } else if (obj.type == 4) {
            str = str + "<td style=\"white-space: nowrap;\">date</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + moment.utc(obj.epoch).format('YYYY-MM-DD HH:mm:ss') + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='the wall time in ms this request took (APT)'>runTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.runTime + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='log record type associated with the request'>logRecordType</td><td  style=\"white-space: nowrap;padding-left: 5px;\"> axapx </td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='thread Id'>tid</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.tid + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='request Id'>reqId</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.reqId + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='wall clock time ms spent in apex code'>apexTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.apexTime + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='wall clock time ms spent in apex call out'>apexCalloutTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.apexCoTime + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='log name of the request'>uri</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.ln + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='time spent ms in db'>oraDbTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.odbTime + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='cpu time ms in db'>dbCpu</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.dbCpu + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='the entry point for this apex execution'>entryPoint</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.cMethod + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='apex compilation time ms'>cmplTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.cmplTime + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='time ms spent in workflow action and rules'>wfTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.wfTime + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='number of soql query executions'>noSoql</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.noSoql + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='what kind of outer execution is this'>quidty</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.quidty + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='is apex debug logging enabled'>isLog</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.isLog + "</td></tr>";
        } else if (obj.type == 5) {
            str = str + "<td style=\"white-space: nowrap;\">date</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + moment.utc(obj.epoch).format('YYYY-MM-DD HH:mm:ss') + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='the wall time in ms this request took (APT)'>runTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.runTime + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='log record type associated with the request'>logRecordType</td><td  style=\"white-space: nowrap;padding-left: 5px;\"> globaldescribe </td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='thread Id'>tid</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.tid + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='request Id'>reqId</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.reqId + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='log name of the request'>uri</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.ln + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='class and method calling getGlobalDescribe'>cMethod</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.cMethod + "</td></tr>";
        } else if (obj.type == 6) {
            str = str + "<td style=\"white-space: nowrap;\" title='start time of the request'>date</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + moment.utc(obj.epoch).format('YYYY-MM-DD HH:mm:ss SSS') + "</td></tr>" +
                "<tr><td  style=\"white-space: nowrap;\" title='organization Id'>orgId</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.orgId + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='user Id'>userId</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.userId + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='the wall time in ms this request took (APT)'>runTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.runTime + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='the amount of cpu time in ms this request took'>cpuTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.cpuTime + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='GC duraiton in ms that impacted this request'>gcTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.gcTime + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='log record type associated with the request'>logRecordType</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.logType + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='rac node'>racNode</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.racNode + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='thread Id'>tid</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.tid + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='request Id'>reqId</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.reqId + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='time spent in database'>dbTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.dbTime + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='time spent ms in db'>oraDbTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.odbTime + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='cpu time ms in db'>dbCpu</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.dbCpu + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='message type'>msgTypeName</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.msg + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='total number of messages in dequeue set'>totalMsg</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.totalMsg + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='time between enqueue and dequeue in ms'>dqLatency</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.dqLatency + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='tier of service for the queue where message is dequeued'>queueTier</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.qTier + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='sfdc Id of the message'>sfdcMsgId</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.sfdcMsgId + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='whether the handler is comitted or un-committed'>dqTrnBhvr</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.dqTrnBhvr + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\" title='type of connection pool used by handler'>connType</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.connType + "</td></tr>";
        }
        //getglobaldescribe call count and time
        let gCount=0;
        let gruntime = 0;

        contextData.records[obj.tid].forEach(function (rec) {
            if (obj.reqId == rec.reqId && rec.type == 5 && (rec.epoch >= obj.epoch && rec.epoch < obj.epoch+obj.runTime)) {
                gCount++;
                gruntime = gruntime + rec.runTime;
            }
        });
        if(obj.tn != undefined){
            str = str + "<tr><td style=\"white-space: nowrap;\">threadName</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.tn + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\">bytesAllocated</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + obj.bytes + "</td></tr>";
        }
        if(gCount != 0){
            str = str + "<tr><td style=\"white-space: nowrap;\">globalDescribeCount</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + gCount + "</td></tr>" +
                "<tr><td style=\"white-space: nowrap;\">globalDescribeTime</td><td  style=\"white-space: nowrap;padding-left: 5px;\">" + gruntime + "</td></tr>";
        }
        return str;
    }

    function filterOnType() {
        console.log("filterOnType 0" );
        let scount = 0;
        let stackMap = {};
        filteredStackMap[FilterLevel.LEVEL1] = {};

        let tidDatalistVal = filterMap["tid"];
        let headerIndexMap = {};
        let metricsHeaderArray = [];
        let metricsIndexArray = [];
        let groupByIndex = -1;
        let spanIndex = -1;
        let timestampIndex=-1;


        for (let val in contextData.header[customEvent]) {
            const tokens = contextData.header[customEvent][val].split(":");
            if (tokens[1] == "number") {
                metricsIndexArray.push(val);
                metricsHeaderArray.push(tokens[0]);
            }
            if (groupBy == tokens[0]) {
                groupByIndex = val;
            }
            if ("duration" == tokens[0]) { // TODO: take from user
                spanIndex = val;
            }
            if ("timestamp" == tokens[0]) { // TODO: take from user
                timestampIndex = val;
            }
            if (tokens[1] == "text" || tokens[1] == "timestamp") {
                headerIndexMap[tokens[0]] = val;
            }
            metricsHeaderArray.push("Count");
        }

        let contextDataRecords = undefined;
        if (contextData != undefined && contextData.records != undefined) {
            contextDataRecords = contextData.records[customEvent];
        }

        let contextStart = getContextTree(1).context.start;
        let contextTidMap = getContextTree(1).context.tidMap;


        if (isFilterEmpty(headerIndexMap) && tidDatalistVal != undefined) {
            for (let i = 0; i < contextTidMap[tidDatalistVal].length; i++) {
                if (stackMap[contextTidMap[tidDatalistVal][i].hash] !== undefined) {
                    stackMap[contextTidMap[tidDatalistVal][i].hash] = stackMap[contextTidMap[tidDatalistVal][i].hash] + 1;
                } else {
                    stackMap[contextTidMap[tidDatalistVal][i].hash] = 1;
                }
                if (isTSView) {
                    if (filteredStackMap[FilterLevel.LEVEL1][tidDatalistVal] == undefined) {
                        filteredStackMap[FilterLevel.LEVEL1][tidDatalistVal] = [];
                    }
                    filteredStackMap[FilterLevel.LEVEL1][tidDatalistVal].push(contextTidMap[tidDatalistVal][i]);
                }
            }
        }else {
            //we are here means one of DatalistVal is not empty
            //contextData.tidlist.forEach(function (tid) {
            for(var tid in contextDataRecords) {
                contextDataRecords[tid].forEach(function (obj) {
                    let flag = false;
                    let record = obj.record;
                    if (filterMatchNew(record, headerIndexMap)) {
                        flag = true;
                    }
                    if (flag) {
                        let end = record[timestampIndex] - contextStart + record[spanIndex];
                        let start =  record[timestampIndex] - contextStart;

                        try {
                            //do a binary search
                            let entryIndex = isinRequest(contextTidMap[tid], start, end);
                            if (entryIndex != -1) {
                                let requestArr = contextTidMap[tid];
                                let curIndex = entryIndex;
                                //consider all matching samples downward
                                while (curIndex >= 0 && requestArr[curIndex].time >= start && requestArr[curIndex].time <= end) {
                                    if (isTSView) {
                                        if (filteredStackMap[FilterLevel.LEVEL1][tid] == undefined) {
                                            filteredStackMap[FilterLevel.LEVEL1][tid] = [];
                                        }
                                        filteredStackMap[FilterLevel.LEVEL1][tid].push(requestArr[curIndex]);
                                    }
                                    if (stackMap[requestArr[curIndex].hash] !== undefined) {
                                        stackMap[requestArr[curIndex].hash] = stackMap[requestArr[curIndex].hash] + 1;
                                    } else {
                                        stackMap[requestArr[curIndex].hash] = 1;
                                    }
                                    scount++;
                                    curIndex--;
                                }
                                curIndex = entryIndex + 1;
                                //consider all matching samples upward
                                while (curIndex < requestArr.length && requestArr[curIndex].time >= start && requestArr[curIndex].time <= end) {
                                    if (isTSView) {
                                        filteredStackMap[FilterLevel.LEVEL1][tid].push(requestArr[curIndex]);
                                    }
                                    if (stackMap[requestArr[curIndex].hash] !== undefined) {
                                        stackMap[requestArr[curIndex].hash] = stackMap[requestArr[curIndex].hash] + 1;
                                    } else {
                                        stackMap[requestArr[curIndex].hash] = 1;
                                    }
                                    scount++;
                                    curIndex++;
                                }
                            }
                        } catch (err) {
                            console.log("tid not found in JFR" + tid + " " + err.message);
                        }
                    }
                });
            }
            // });
        }
        for (stack in stackMap) {
            getTreeStackLevel(getActiveTree(getEventType(), false), stack, stackMap[stack], FilterLevel.LEVEL1);
        }
        console.log("filterOnType 1" );
    }

    function showRequestTimelineView(tid, time, applyFilter) {
        let str = "";
        let table = "";
        let runTime = 0;
        let profilestart = 0;

        if (getContextTree(1, EventType.METHOD) != undefined) {
            profilestart =  getContextTree(1,EventType.METHOD).context.start;
        }else{
            profilestart =  getContextTree(1).context.start;
        }

        let start = time - profilestart;

        let jstackstart = 0;
        let jstackdiff = 0;
        if(getContextTree(1,EventType.JSTACK) !== undefined) {
            jstackstart = time - getContextTree(1,EventType.JSTACK).context.start;
            jstackdiff = getContextTree(1,EventType.JSTACK).context.start - profilestart;
        }

        let colorStackStr = "";
        let reqId = "";

        contextData.records[tid].forEach(function (obj) {
            if (obj.epoch == time) {
                reqId = obj.reqId;
                runTime = obj.runTime;
                str = getContextView(obj);
                return false;
            }
        });

        let str1 = "<table><tr>";
        let scount = 0;
        let srwcount = 0;
        //identify stacks
        const tmpIdMap = new Map();

        if(applyFilter) {
            filteredStackMap[FilterLevel.LEVEL2] = {};
        }


        if (getContextTree(1, EventType.METHOD) != undefined && getContextTree(1, EventType.METHOD).context != undefined && getContextTree(1, EventType.METHOD).context.tidMap[tid] !== undefined) {
            getContextTree(1, EventType.METHOD).context.tidMap[tid].forEach(function (obj) {
                if (obj.time >= start && obj.time <= start + runTime ) {
                    tmpIdMap.set(obj.hash + "_method"+"_" + obj.time, obj.time);
                    scount++;
                    if (getEventType() == EventType.METHOD) {
                        if(applyFilter) {
                            getTreeStackLevel(getActiveTree(EventType.METHOD, false), obj.hash, 1, FilterLevel.LEVEL2);
                        }
                    }
                }
            });
        }
        if (getContextTree(1, EventType.SOCKET) !== undefined && getContextTree(1, EventType.SOCKET).context != undefined && getContextTree(1, EventType.SOCKET).context.tidMap[tid] !== undefined) {
            getContextTree(1, EventType.SOCKET).context.tidMap[tid].forEach(function (obj) {
                if (obj.time >= start && obj.time <= start + runTime ) {
                    if (getEventType() == EventType.SOCKET) {
                        if(applyFilter) {
                            getTreeStackLevel(getActiveTree(EventType.SOCKET, false), obj.hash, 1, FilterLevel.LEVEL2);
                        }
                    }
                    tmpIdMap.set(obj.hash + "_socket"+"_" + obj.time, obj.time);
                    scount++;
                    srwcount++;
                }
            });
        }
        if (getContextTree(1, EventType.APEX) !== undefined && getContextTree(1, EventType.APEX).context != undefined && getContextTree(1, EventType.APEX).context.tidMap[tid] !== undefined) {
            getContextTree(1, EventType.APEX).context.tidMap[tid].forEach(function (obj) {
                if (obj.time >= start && obj.time <= start + runTime ) {
                    if (getEventType() == EventType.APEX) {
                        if(applyFilter) {
                            getTreeStackLevel(getActiveTree(EventType.APEX, false), obj.hash, 1, FilterLevel.LEVEL2);
                        }
                    }
                    tmpIdMap.set(obj.hash + "_apex" +"_" + obj.time, obj.time);
                    scount++;
                }
            });
        }

        if (getContextTree(1, EventType.NATIVE) !== undefined && getContextTree(1, EventType.NATIVE).context != undefined && getContextTree(1, EventType.NATIVE).context.tidMap[tid] !== undefined) {
            getContextTree(1, EventType.NATIVE).context.tidMap[tid].forEach(function (obj) {
                if (obj.time >= start && obj.time <= start + runTime ) {
                    if (getEventType() == EventType.NATIVE) {
                        if(applyFilter) {
                            getTreeStackLevel(getActiveTree(EventType.NATIVE, false), obj.hash, 1, FilterLevel.LEVEL2);
                        }
                    }
                    tmpIdMap.set(obj.hash + "_native" +"_" + obj.time, obj.time);
                    scount++;
                }
            });
        }

        if (getContextTree(1, EventType.JSTACK) !== undefined && getContextTree(1, EventType.JSTACK).context != undefined && getContextTree(1, EventType.JSTACK).context.tidMap[tid] !== undefined) {
            getContextTree(1, EventType.JSTACK).context.tidMap[tid].forEach(function (obj) {
                if (obj.time >= jstackstart && obj.time <= jstackstart + runTime ) {
                    if (getEventType() == EventType.JSTACK) {
                        if(applyFilter) {
                            getTreeStackLevel(getActiveTree(EventType.JSTACK, false), obj.hash, 1, FilterLevel.LEVEL2);
                        }
                    }
                    if(isTSView && applyFilter) {
                        if (filteredStackMap[FilterLevel.LEVEL2][tid] == undefined) {
                            filteredStackMap[FilterLevel.LEVEL2][tid] = [];
                        }
                        filteredStackMap[FilterLevel.LEVEL2][tid].push(obj);
                    }

                    tmpIdMap.set(obj.hash + "_jstack" +"_" + obj.time, obj.time + jstackdiff);
                    scount++;
                }
            });
        }


        const tmpIdMapSorted = new Map([...tmpIdMap.entries()].sort((a, b) => a[1] - b[1]));
        let startTime = profilestart;
        let firstfilterStack = "";
        for (let [key, value] of tmpIdMapSorted) {
            let epoch = startTime + value;
            let pair = key.split("_");
            if(firstfilterStack == ""){
                firstfilterStack = pair[0] + "_" + epoch;
            }

            if(applyFilter) {
                if (pair[1] == "method") {
                    str1 = str1 + "<td class=\"zoom stackCell\" id=\"" + pair[0] + "-" + epoch + "\" onclick=\"showStack(" + pair[0] + "," + epoch + "," + EventType.METHOD + ", this)\"> </td>";
                } else if (pair[1] == "socket") {
                    str1 = str1 + "<td class=\"zoom socketCell\" id=\"" + pair[0] + "-" + epoch + "\" onclick=\"showStack(" + pair[0] + "," + epoch + "," + EventType.SOCKET + ", this)\"> </td>";
                } else if (pair[1] == "apex") {
                    str1 = str1 + "<td class=\"zoom apexCell\" id=\"" + pair[0] + "-" + epoch + "\" onclick=\"showStack(" + pair[0] + "," + epoch + "," + EventType.APEX + ", this)\"> </td>";
                } else if (pair[1] == "native") {
                    str1 = str1 + "<td class=\"zoom nativeCell\" id=\"" + pair[0] + "-" + epoch + "\" onclick=\"showStack(" + pair[0] + "," + epoch + "," + EventType.NATIVE + ", this)\"> </td>";
                }else if (pair[1] == "jstack") {
                    str1 = str1 + "<td class=\"zoom jstackCell\" id=\"" + pair[0] + "-" + epoch + "\" onclick=\"showStack(" + pair[0] + "," + epoch + "," + EventType.JSTACK + ", this)\"> </td>";
                }
            }else{
                if (pair[1] == "method") {
                    str1 = str1 + "<td class=\"zoom stackCell\" id=\"" + pair[0] + "-" + epoch + "_pop\" onclick=\"showpopStack(" + pair[0] + "," + epoch + "," + EventType.METHOD + ", this)\"> </td>";
                } else if(pair[1] == "socket") {
                    str1 = str1 + "<td class=\"zoom socketCell\" id=\"" + pair[0] + "-" + epoch + "_pop\" onclick=\"showpopStack(" + pair[0] + "," + epoch + "," + EventType.SOCKET + ", this)\"> </td>";
                }else if(pair[1] == "apex"){
                    str1 = str1 + "<td class=\"zoom apexCell\" id=\"" + pair[0] + "-" + epoch + "_pop\" onclick=\"showpopStack(" + pair[0] + "," + epoch + "," + EventType.APEX + ", this)\"> </td>";
                }else if(pair[1] == "native"){
                    str1 = str1 + "<td class=\"zoom nativeCell\" id=\"" + pair[0] + "-" + epoch + "_pop\" onclick=\"showpopStack(" + pair[0] + "," + epoch + "," + EventType.NATIVE + ", this)\"> </td>";
                }else if(pair[1] == "jstack"){
                    str1 = str1 + "<td class=\"zoom jstackCell\" id=\"" + pair[0] + "-" + epoch + "_pop\" onclick=\"showpopStack(" + pair[0] + "," + epoch + "," + EventType.JSTACK + ", this)\"> </td>";
                }
            }
        }

        //set default to 1st stack
        if(applyFilter) {
            if (filterStack == "") {
                filterStack = firstfilterStack;
            }
        }else{
            if (popfilterStack == "") {
                popfilterStack = firstfilterStack;
            }
        }

        str1 = str1 + "</tr></table>";

        let timelinetitleID = "timelinetitle";
        let threadstateID = "threadstate";
        let stackcontextID = "stackcontext";
        let stackID = "stack";

        if(!applyFilter) {
            timelinetitleID = "timelinepopuptitle";
            threadstateID = "popupthreadstate";
            stackcontextID = "popupstackcontext";
            stackID = "popupstack";
        }
        let jstackinterval = '60';
        if(getContextTree(1,EventType.JSTACK) != undefined && getContextTree(1,EventType.JSTACK).meta != undefined && getContextTree(1,EventType.JSTACK).meta['jstack-interval'] != undefined){
            jstackinterval = getContextTree(1,EventType.JSTACK).meta['jstack-interval'];
        }
        document.getElementById(timelinetitleID).innerHTML = "<select multiple=\"multiple\" style=\"border-color:#F2F2F3; height: 24px; width: 223px;\" name=\"timeline-event-type\" id=\"timeline-event-type\"> " +
            "<option "+ ((multiSelect["method"] != undefined) ? "selected" : "") + " value=\"method\">Java (Thread State(s): Runnable, Sampling Frequency: 10 ms)</option>" +
            "<option "+ ((multiSelect["socket"] != undefined) ? "selected" : "") + " value=\"socket\">Java (Thread State(s): Socket R/W, Threshold: 200 ms)</option>" +
            "<option "+ ((multiSelect["apex"] != undefined) ? "selected" : "") + "  value=\"apex\">Apex (Thread State(s): All, Sampling Frequency: 2 s)</option>" +
            "<option "+ ((multiSelect["jstack"] != undefined) ? "selected" : "") + "  value=\"jstack\">Java (Thread State(s): All, Sampling Frequency: "+jstackinterval+" s)</option>" +
            "<option "+ ((multiSelect["native"] != undefined) ? "selected" : "") + " value=\"native\">Java native (Thread State(s): All, Sampling Frequency: 10 ms)</option>" +
            "</select>" +
            "&nbsp;profiling samples for reqId " + reqId + " " + moment.utc(Number(time)).format('YYYY-MM-DD HH:mm:ss.SSS') + " to " + moment.utc(Number(time) + runTime).format('YYYY-MM-DD HH:mm:ss.SSS');

        document.getElementById(threadstateID).innerHTML = str1;
        str = str + "<tr><td style=\"white-space: nowrap;\" title='total samples collected in this request'>samples</td><td style=\"white-space: nowrap;padding-left: 5px;\" >" + scount + " </td></tr>";
        str = str + "<tr><td style=\"white-space: nowrap;\" title='socket R/W count (tracing threshold 200ms)'>socket R/W count</td><td style=\"white-space: nowrap;padding-left: 5px;\" >" + srwcount + " (tracing threshold 200ms) </td></tr>";
        if (str != "") {
            table = table + colorStackStr;
            table = table + "<table style=\"width:100%; padding: 0px;\" class=\" table-striped\" >";
            table = table + str;
            table = table + "</table>";

        }
        document.getElementById(stackcontextID).innerHTML = table;
        document.getElementById(stackID).innerHTML = "";
        $('#timeline-event-type').multiselect({
            buttonWidth: '200px',
            numberDisplayed: 1,
            onDropdownHide: function(event) {
                let isChanged = false;
                let tmpmultiSelect={};
                var values = $('#timeline-event-type').val();
                for(let i=0; i< values.length; i++){
                    if(multiSelect[values[i]] == undefined){
                        isChanged = true;
                    }
                    tmpmultiSelect[values[i]] = "selected";
                }
                for(var key in multiSelect){
                    if(tmpmultiSelect[key] == undefined){
                        isChanged = true;
                    }
                }
                if(isChanged){
                    let newmultiSelect = "";
                    let separator = "";
                    for(var key in tmpmultiSelect){
                        newmultiSelect = newmultiSelect+separator+key;
                        if(separator == ""){
                            separator = ";";
                        }

                    }
                    updateUrl("mSelect", newmultiSelect, true);
                    multiSelect=tmpmultiSelect;
                    updateThreadStateView();
                }
            }
        });
        updateThreadStateView();
    }

    function updateThreadStateView() {
        let array = ["method", "socket", "native", "apex", "jstack"];
        for (var i in array) {
            if (multiSelect[array[i]] != undefined) {
                if (array[i] == "method") {
                    $('.stackCell').removeClass('hide');
                } else {
                    $('.' + array[i] + "Cell").removeClass('hide');
                }
            } else {
                if (array[i] == "method") {
                    $('.stackCell').addClass('hide');
                } else {
                    $('.' + array[i] + "Cell").addClass('hide');
                }
            }
        }
        let element = undefined;
        if ($("#popupthreadstate").length != 0) {
            let stackPair = popfilterStack.split("_");
            if ($("#" + stackPair[0] + "-" + stackPair[1] + "_pop").length != 0 && !$("#" + stackPair[0] + "-" + stackPair[1] + "_pop").hasClass("stackCells")) {
                $("#" + stackPair[0] + "-" + stackPair[1] + "_pop").click();
            } else {
                element = $("#popupthreadstate table tbody tr td").not(".hide");
                if (element != undefined && element[0] != undefined && !element[0].classList.contains("stackCells")) {
                    element[0].click();
                }
            }
        } else {
            let stackPair = filterStack.split("_");
            if ($("#" + stackPair[0] + "-" + stackPair[1]).length != 0 && !$("#" + stackPair[0] + "-" + stackPair[1]).hasClass("stackCells")) {
                $("#" + stackPair[0] + "-" + stackPair[1]).click();
            } else {
                element = $("#threadstate table tbody tr td").not(".hide");
                if (element != undefined && element[0] != undefined && !element[0].classList.contains("stackCells")) {
                    element[0].click();
                }
            }
        }
    }

    function isFilterEmpty(headerIndexMap) {
        if(headerIndexMap == undefined){
            headerIndexMap = {};
            for (let val in contextData.header[customEvent]) {
                const tokens = contextData.header[customEvent][val].split(":");
                if(tokens[1] == "text" || tokens[1] == "timestamp"){
                    headerIndexMap[tokens[0]]=val;
                }
            }
        }
        let isEmpty = true;
        for(dim in headerIndexMap){
            if(filterMap[dim] != undefined && dim != "tid"){ //handle tid separately
                isEmpty=false;
            }
        }
        return isEmpty;
    }

    function filterMatchNew(record,headerIndexMap) {
        for(dim in headerIndexMap){
            if(!(filterMap[dim] == undefined || record[headerIndexMap[dim]].includes(filterMap[dim]))){
                return false;
            }
        }
        return true;
    }

    function filterMatch(obj,contextType) {
        if (contextType == 2) {
            if ((filterMap["org"] == undefined || filterMap["org"] == obj.orgId) &&
                (filterMap["user"] == undefined || filterMap["user"] == obj.userId) &&
                (filterMap["log"] == undefined || filterMap["log"] == obj.logType) &&
                (filterMap["uri"] == undefined || filterMap["uri"] == obj.ln) &&
                (filterMap["thread_name"] == undefined || obj.tn.includes(filterMap["thread_name"])) &&
                (filterMap["rac"] == undefined || filterMap["rac"] == obj.racNode) &&
                (filterMap["tid"] == undefined || filterMap["tid"] == obj.tid) &&
                (filterMap["trust"] == undefined || filterMap["trust"] == obj.trust) &&
                (filterMap["req"] == undefined || filterMap["req"] == obj.reqId)) {
                return true;
            }
        } else if (contextType == -1) {
            if ((filterMap["org"] == undefined || filterMap["org"] == obj.orgId) &&
                (filterMap["user"] == undefined || filterMap["user"] == obj.userId) &&
                (filterMap["log"] == undefined || filterMap["log"] == obj.logType) &&
                (filterMap["uri"] == undefined || filterMap["uri"] == obj.ln) &&
                (filterMap["thread_name"] == undefined || obj.tn.includes(filterMap["thread_name"])) &&
                (filterMap["rac"] == undefined || filterMap["rac"] == obj.racNode) &&
                (filterMap["tid"] == undefined || filterMap["tid"] == obj.tid) &&
                (filterMap["trust"] == undefined || filterMap["trust"] == obj.trust) &&
                (filterMap["tier"] == undefined || filterMap["tier"] == obj.qTier) &&
                (filterMap["sfdcmsgid"] == undefined || filterMap["sfdcmsgid"] == obj.sfdcMsgId) &&
                (filterMap["req"] == undefined || filterMap["req"] == obj.reqId)) {
                return true;
            }
        } else if (contextType == 6) {
            if ((filterMap["org"] == undefined || filterMap["org"] == obj.orgId) &&
                (filterMap["log"] == undefined || filterMap["log"] == obj.logType) &&
                (filterMap["uri"] == undefined || filterMap["uri"] == obj.ln) &&
                (filterMap["thread_name"] == undefined || obj.tn.includes(filterMap["thread_name"])) &&
                (filterMap["rac"] == undefined || filterMap["rac"] == obj.racNode) &&
                (filterMap["tid"] == undefined || filterMap["tid"] == obj.tid) &&
                (filterMap["tier"] == undefined || filterMap["tier"] == obj.qTier) &&
                (filterMap["sfdcmsgid"] == undefined || filterMap["sfdcmsgid"] == obj.sfdcMsgId) &&
                (filterMap["req"] == undefined || filterMap["req"] == obj.reqId)) {
                return true;
            }
        }
        return false;
    }

    function getHearderFor(field){
        switch(field) {
            case "tn": return "threadName";
            case "tid": return "threadId";
            case "userId": return "userId";
            case "orgId": return "orgId";
            case "logType": return "logRecordType";
            case "reqId": return "requestId";
            case "ln": return "uri/logName";
            case "racNode": return "racNode";
            case "none": return "timestamp";
            case "msg": return "messageType";
            case "qTier": return "queueTier";
            default: return field;
        }
    }

    function getContextTableHeader(groupBy, contextDataTypeVal) {
        if (groupBy == "none") {
            return "<thead><tr><th>time</th><th>tid</th><th title='organization Id'>orgId</th><th title='user Id'>userId</th><th title='log record type associated with the request'>log</th><th title='log name/message type of the request'>uri</th><th>threadName</th><th title='request Id'>reqId</th>" +
                "<th title='the wall time in ms this request took (APT)'>runTime</th><th  title='the amount of cpu time in ms this request took'>cpuTime</th><th title='time spent in database'>dbTime</th><th title='wall clock time ms spent in apex code'>apexTime</th><th title='cpu time ms in db'>dbCpuTime</th><th title='GC duraiton in ms that impacted this request'>gcTime</th><th title='time spent waiting for and including a safepoint'>spTime</th><th>bytesAllocated</th><th title='time between enqueue and dequeue in ms'>dequeueLatency</th></tr></thead>";
        } else {
            if (groupBy == "userId") {
                return "<thead><tr><th title='user Id'>userId</th><th title='organization Id'>orgId</th><th title='the wall time in ms this request took (APT)'>runTime</th><th  title='the amount of cpu time in ms this request took'>cpuTime</th><th title='time spent in database'>dbTime</th><th title='wall clock time ms spent in apex code'>apexTime</th><th title='cpu time ms in db'>dbCpuTime</th><th title='GC duraiton in ms that impacted this request'>gcTime</th><th title='time spent waiting for and including a safepoint'>spTime</th><th>bytesAllocated</th><th title='time between enqueue and dequeue in ms'>dequeueLatency</th><th>reqCount</th></tr></thead>";
            } else {
                return "<thead><tr><th>" + getHearderFor(groupBy) + "</th><th title='the wall time in ms this request took (APT)'>runTime</th><th  title='the amount of cpu time in ms this request took'>cpuTime</th><th title='time spent in database'>dbTime</th><th title='wall clock time ms spent in apex code'>apexTime</th><th title='cpu time ms in db'>dbCpuTime</th><th title='GC duraiton in ms that impacted this request'>gcTime</th><th title='time spent waiting for and including a safepoint'>spTime</th><th>bytesAllocated</th><th title='time between enqueue and dequeue in ms'>dequeueLatency</th><th>reqCount</th></tr></thead>";
            }
        }
    }

    function getContextTableRow(obj, tableFormat) {
        if (tableFormat == 0) {
            if (obj.type == 4) {
                return "<tr><td>" + moment.utc(obj.epoch).format('YYYY:MM:DD.HH:mm:ss.SSS') + "</td><td tp=6 class=\"context-menu-two\">" + obj.tid + "</td><td tp=0 class=\"context-menu-two\">" + obj.orgId + "</td><td tp=1 class=\"context-menu-two\">" + obj.userId + "</td><td tp=2 class=\"context-menu-two\">axapx</td><td tp=4 class=\"context-menu-two\">" + obj.ln + "</td><td tp=8 class=\"context-menu-two\">" + obj.tn + "</td><td tp=3 class=\"context-menu-one\" id=\"" + obj.tid + "_" + obj.epoch + "\">" + obj.reqId + "</td><td>" + obj.runTime + "</td><td>" + obj.cpuTime + "</td><td>" + (obj.dbTime == undefined ? "NA" :  obj.dbTime) + "</td><td>" + obj.apexTime + "</td><td>" + obj.dbCpu + "</td><td>" + obj.gcTime + "</td><td>" + obj.spTime + "</td><td>" + obj.bytes + "</td><td>" + (obj.dqLatency == undefined ? "NA" :  obj.dqLatency) + "</td></tr>";
            } else if (obj.type == 6) {
                return "<tr><td>" + moment.utc(obj.epoch).format('YYYY:MM:DD.HH:mm:ss.SSS') + "</td><td tp=6 class=\"context-menu-two\">" + obj.tid + "</td><td tp=0 class=\"context-menu-two\">" + obj.orgId + "</td><td tp=1 class=\"context-menu-two\">NA</td><td tp=2 class=\"context-menu-two\">" + obj.logType + "</td><td tp=4 class=\"context-menu-two\">" + obj.ln + "</td><td tp=8 class=\"context-menu-two\">" + obj.tn + "</td><td tp=3 class=\"context-menu-one\" id=\"" + obj.tid + "_" + obj.epoch + "\">" + obj.reqId + "</td><td>" + obj.runTime + "</td><td>" + obj.cpuTime + "</td><td>" + (obj.dbTime == undefined ? "NA" :  obj.dbTime) + "</td><td>NA</td><td>" + obj.dbCpu + "</td><td>NA</td><td>NA</td><td>" + obj.bytes + "</td><td>" + (obj.dqLatency == undefined ? "NA" :  obj.dqLatency) + "</td></tr>";
            } else {
                return "<tr><td>" + moment.utc(obj.epoch).format('YYYY:MM:DD.HH:mm:ss.SSS') + "</td><td tp=6 class=\"context-menu-two\">" + obj.tid + "</td><td tp=0 class=\"context-menu-two\">" + obj.orgId + "</td><td tp=1 class=\"context-menu-two\">" + obj.userId + "</td><td tp=2 class=\"context-menu-two\">" + obj.logType + "</td><td tp=4 class=\"context-menu-two\">" + obj.ln + "</td><td tp=8 class=\"context-menu-two\">" + obj.tn + "</td><td tp=3 class=\"context-menu-one\" id=\"" + obj.tid + "_" + obj.epoch + "\">" + obj.reqId + "</td><td>" + obj.runTime + "</td><td>" + obj.cpuTime + "</td><td>" + (obj.dbTime == undefined ? "NA" :  obj.dbTime) + "</td><td>" + obj.apexTime + "</td><td>" + obj.dbCpu + "</td><td>" + obj.gcTime + "</td><td>" + obj.spTime + "</td><td>" + obj.bytes + "</td><td>NA</td></tr>";
            }
        } else {
            if (obj.type == 4) {
                return "<tr><td>" + moment.utc(obj.epoch).format('YYYY:MM:DD.HH:mm:ss.SSS') + "</td><td tp=6 class=\"context-menu-two\">" + obj.tid + "</td><td tp=0 class=\"context-menu-two\">" + obj.orgId + "</td><td tp=1 class=\"context-menu-two\">" + obj.userId + "</td><td tp=2 class=\"context-menu-two\">axapx</td><td tp=4 class=\"context-menu-two\">" + obj.ln + "</td><td tp=8 class=\"context-menu-two\">" + obj.tn + "</td><td tp=3 class=\"context-menu-one\" id=\"" + obj.tid + "_" + obj.epoch + "\">" + obj.reqId + "</td><td>" + (100 * obj.runTime / obj.runTime).toFixed(2) + "%</td><td>" + (100 * obj.cpuTime / obj.runTime).toFixed(2) + "%</td><td>" + (obj.dbTime == undefined ? "NA" : (100 * obj.dbTime / obj.runTime).toFixed(2)) + "%</td><td>" + (100 * obj.apexTime / obj.runTime).toFixed(2) + "%</td><td>" + (100 * obj.dbCpu / obj.runTime).toFixed(2) + "%</td><td>" + (100 * obj.gcTime / obj.runTime).toFixed(2) + "%</td><td>" + (100 * obj.spTime / obj.runTime).toFixed(2) + "%</td><td>" + obj.bytes + "</td><td>" + (obj.dqLatency == undefined ? "NA" :  obj.dqLatency) + "</td></tr>"
            } else if (obj.type == 6) {
                return "<tr><td>" + moment.utc(obj.epoch).format('YYYY:MM:DD.HH:mm:ss.SSS') + "</td><td tp=6 class=\"context-menu-two\">" + obj.tid + "</td><td tp=0 class=\"context-menu-two\">" + obj.orgId + "</td><td tp=1 class=\"context-menu-two\">NA</td><td tp=2 class=\"context-menu-two\">" + obj.logType + "</td><td tp=4 class=\"context-menu-two\">" + obj.ln + "</td><td tp=8 class=\"context-menu-two\">" + obj.tn + "</td><td tp=3 class=\"context-menu-one\" id=\"" + obj.tid + "_" + obj.epoch + "\">" + obj.reqId + "</td><td>" + (100 * obj.runTime / obj.runTime).toFixed(2) + "%</td><td>" + (100 * obj.cpuTime / obj.runTime).toFixed(2) + "%</td><td>" + (obj.dbTime == undefined ? "NA" : (100 * obj.dbTime / obj.runTime).toFixed(2)) + "%</td><td>NA</td><td>" + (100 * obj.dbCpu / obj.runTime).toFixed(2) + "%</td><td>NA</td><td>NA</td><td>" + obj.bytes + "</td><td>" + (obj.dqLatency == undefined ? "NA" :  obj.dqLatency) + "</td></tr>";
            } else {
                return "<tr><td>" + moment.utc(obj.epoch).format('YYYY:MM:DD.HH:mm:ss.SSS') + "</td><td tp=6 class=\"context-menu-two\">" + obj.tid + "</td><td tp=0 class=\"context-menu-two\">" + obj.orgId + "</td><td tp=1 class=\"context-menu-two\">" + obj.userId + "</td><td tp=2 class=\"context-menu-two\">" + obj.logType + "</td><td tp=4 class=\"context-menu-two\">" + obj.ln + "</td><td tp=8 class=\"context-menu-two\">" + obj.tn + "</td><td tp=3 class=\"context-menu-one\" id=\"" + obj.tid + "_" + obj.epoch + "\">" + obj.reqId + "</td><td>" + (100 * obj.runTime / obj.runTime).toFixed(2) + "%</td><td>" + (100 * obj.cpuTime / obj.runTime).toFixed(2) + "%</td><td>" + (obj.dbTime == undefined ? "NA" : (100 * obj.dbTime / obj.runTime).toFixed(2)) + "%</td><td>" + (100 * obj.apexTime / obj.runTime).toFixed(2) + "%</td><td>" + (100 * obj.dbCpu / obj.runTime).toFixed(2) + "%</td><td>" + (100 * obj.gcTime / obj.runTime).toFixed(2) + "%</td><td>" + (100 * obj.spTime / obj.runTime).toFixed(2) + "%</td><td>" + obj.bytes + "</td><td>NA</td></tr>";
            }
        }
    }

    var randomColor = (function(){
        var golden_ratio_conjugate = 0.618033988749895;
        var h = Math.random();

        var hslToRgb = function (h, s, l){
            var r, g, b;

            if(s == 0){
                r = g = b = l; // achromatic
            }else{
                function hue2rgb(p, q, t){
                    if(t < 0) t += 1;
                    if(t > 1) t -= 1;
                    if(t < 1/6) return p + (q - p) * 6 * t;
                    if(t < 1/2) return q;
                    if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                }

                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }

            return '#'+Math.round(r * 255).toString(16)+Math.round(g * 255).toString(16)+Math.round(b * 255).toString(16);
        };

        return function(){
            h += golden_ratio_conjugate;
            h %= 1;
            return hslToRgb(h, 0.5, 0.60);
        };
    })();
    function svgShowReq(evt) {
        var svgobj=evt.target;
        if(svgobj.getAttribute("style") == undefined || !svgobj.getAttribute("style").includes("opacity: 0")) {
            showRequestContextPopup(svgobj.getAttribute("id"));
        }
    }
    function OnScroll0(div) {
        var d2 = document.getElementById("requestbarchart");
        d2.scrollTop = div.scrollTop;
    }
    function OnScroll1(div) {
        var d2 = document.getElementById("requestbarchart");
        d2.scrollLeft = div.scrollLeft;
    }
    function OnScroll2(div) {
        var d1 = document.getElementById("xaxisid");
        var d0 = document.getElementById("yaxisid");
        d0.scrollTop = div.scrollTop;
        d1.scrollLeft = div.scrollLeft;
    }
    function addXAxis(id,top,right,bottom,left,min_x,max_x,w,h,contextStart,downScale){
        const margin = {top: top, right: right, bottom: bottom, left: left};
        const width = w - margin.left - margin.right,
            height = h - margin.top - margin.bottom;
        const g = d3.select(id).append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        let ticCount = (max_x - min_x)/75;

        let xScale = d3.scaleLinear()
            .domain([min_x, max_x])
            .range([0, width]);

        let curTick = 0;
        let xAxisGenerator = d3.axisBottom()
            .scale(xScale)
            .tickPadding(5)
            .ticks(ticCount)
            .tickFormat(function (d) {
                if(curTick==0){
                    curTick=1;
                    return moment.utc(d*downScale+contextStart).format('MM-DD HH:mm:ss');
                }else{
                    return moment.utc(d*downScale+contextStart).format('mm:ss');
                }
            });

        let xAxis =  g.append("g")
            .call(xAxisGenerator);

        xAxis.selectAll(".tick text")
            .attr("y", 6)
            .attr("x", 6)
            .style("text-anchor", "start");
    }
    function addYAxis(id,top,right,bottom,left,min_x,max_x,w,h){
        const margin = {top: top, right: right, bottom: bottom, left: left};
        const width = w - margin.left - margin.right,
            height = h - margin.top - margin.bottom;
        const g = d3.select(id).append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        let xScale = d3.scaleLinear()
            .domain([min_x, max_x])
            .range([0, h]);

        g.append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", -20)
            .attr("x",-100)
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text("Thread ID");

        let xAxisGenerator = d3.axisRight()
            .scale(xScale)
            //.tickPadding(5)
            .ticks(max_x)
            .tickSize(4)
            .tickFormat(function (d) {
                return tidIndex[d];
            });

        let xAxis =  g.append("g")
            .call(xAxisGenerator);

        xAxis.selectAll(".tick text")
            .style("font-size",8)
            .attr("y", 4)
            .attr("x", 3)
            .style("text-anchor", "start");
    }

    function drowStateChart(filteredTidRequests,chartWidth,downScale,minStart,chartHeight,tidSortByMetricMap){
        document.getElementById("statetable").innerHTML="<div class='col-lg-12' style='padding: 0 !important;'>"
            + "<div  style='width: 4%;float: left;'></div>"
            + "<div style=\"max-height: 50px;overflow: hidden;width: 96%;float: right;\">"
            + "<div class='col-lg-12' style='padding: 0 !important;'>"
            + "<div class='xaxisid col-lg-10' id='xaxisid' style=\"padding: 0 !important; max-height: 50px;overflow: scroll;overflow-y: hidden;\" onscroll='OnScroll1(this)'>"
            + "</div>"
            + "<div class='col5 col-lg-2' style=\"padding: 0 !important; max-height: 50px;overflow: hidden;\" id='col5'>"
            + "</div>"
            + "</div>"
            + "</div>"
            + "</div>"
            + "<div class='col-lg-12' style='padding: 0 !important;'>"
            + "<div  id='yaxisid' style=\"max-height: 400px;overflow: scroll;overflow-x: hidden;width: 4%;float: left;\" class='yaxisid' onscroll='OnScroll0(this)'></div>"
            + "<div style=\"max-height: 400px;overflow: hidden;width: 96%;float: right;\">"
            + "<div class='col-lg-12' style='padding: 0 !important;'>"
            + "<div class='requestbarchart col-lg-10' onscroll='OnScroll2(this)' style=\"padding: 0 !important; height: 400px;max-height: 400px;overflow: auto;\" id='requestbarchart'>"
            + "</div>"
            + "<div class='legendid col-lg-2' style=\"padding: 10px !important; height: 400px; max-height: 400px;overflow: auto;\" id='legendid'>"
            + "</div>"
            + "</div>"
            + "</div>"
            + "</div>";

        d3.select("#requestbarchart").append("svg").attr("width", chartWidth).attr("height", chartHeight);

        Tooltip = d3.select("#requestbarchart")
            .append("div")
            .style("opacity", 0)
            .attr("class", "tooltip")
            .style("background-color", "white")
            .style("border", "solid")
            .style("border-width", "2px")
            .style("border-radius", "5px")
            .style("padding", "5px");

        let h = 8;
        let y = 0;

        for (let [tid, value] of tidSortByMetricMap){
            let curTime = minStart;
            let x = 0;
            for(let index of filteredTidRequests[tid]) {
                let o =contextData.records[tid][index];
                let tmpEpoch = o.epoch;
                let tmpRunTime=o.runTime;
                if(tmpEpoch < minStart){
                    tmpRunTime = tmpRunTime-(minStart-tmpEpoch);
                    tmpEpoch=minStart;
                }
                if(tmpEpoch>=curTime){
                    d3.select("#requestbarchart").select("svg").append("rect")
                        .attr("width", (tmpEpoch-curTime) / downScale)
                        .attr("height", h)
                        .attr("x", x)
                        .attr("y", y)
                        .attr("fill", "white");

                    x=x+(tmpEpoch-curTime) / downScale;
                    let key =  eval("o." + groupBy);
                    let metricVal =  eval("o." + sortBy);
                    let key1 = tmpColorMap.get(key);
                    key1=key1.replace("#","_");
                    if(tmpRunTime > 200) {
                        d3.select("#requestbarchart").select("svg").append("rect")
                            .attr("width", tmpRunTime / downScale)
                            .attr("height", h)
                            .attr("d", key)
                            .attr("x", x)
                            .attr("y", y)
                            .attr("fill", tmpColorMap.get(key))
                            .attr("class", key1 + " tgl")
                            .attr("onclick", 'svgShowReq(evt)')
                            .attr("id", o.tid + "_" + o.epoch)
                            .on("mouseover", function () {
                                return mouseoverSVG(key1, this);
                            })
                            .on("mousemove", function () {
                                return mousemoveSVG(getHearderFor(groupBy) + ": " + key, key1, this, sortBy + ": " + metricVal);
                            })
                            .on("mouseleave", function () {
                                return mouseleaveSVG(key1, this);
                            });
                    }

                    x=x+tmpRunTime/downScale;

                    curTime=tmpEpoch+tmpRunTime;
                }

            }
            y=y+h;
        }
    }
    var Tooltip = undefined;
    var mouseoverSVG = function(key,obj) {
        if(d3.select(obj).attr("style") == undefined || !d3.select(obj).attr("style").includes("opacity: 0")) {

            Tooltip
                .style("opacity", 1);

            d3.select(obj)
                .style("stroke", "black")
                .style("cursor", "pointer");
        }
    }
    var mousemoveSVG = function(d, key,obj,metricVal) {
        if(d3.select(obj).attr("style") == undefined || !d3.select(obj).attr("style").includes("opacity: 0")) {
            Tooltip
                .html(d + ", " + metricVal + '<br>Click to see request profile samples and context')
                .style("left", (d3.mouse(obj)[0] + 20) + "px")
                .style("top", (d3.mouse(obj)[1]) + "px");
        }
    }
    var mouseleaveSVG = function(key,obj) {
        if(d3.select(obj).attr("style") == undefined || !d3.select(obj).attr("style").includes("opacity: 0")) {
            Tooltip
                .style("opacity", 0);
            d3.select(obj)
                .style("stroke", "none")
                .style("cursor", "default");
        }
    }

    function legendMouseOver(e,key){
        if(!e.hasAttribute("dimmed")) {
            d3.selectAll("." + key).classed("requestHover", true);
        }
        e.style.cursor = "pointer";
    }
    function legendMouseOut(e,key,color){
        if(!e.hasAttribute("dimmed")) {
            d3.selectAll("." + key).classed("requestHover", false);
        }
        e.style.cursor = "default";
    }

    function disableCategory(e,key){
        if(e.hasAttribute("dimmed")) {
            d3.selectAll("." + key).style("opacity", 1);
            e.removeAttribute("dimmed");
            e.style.opacity = 1;
        }else{
            d3.selectAll("." + key).style("opacity", 0);
            e.setAttribute("dimmed",true);
            e.style.opacity = 0.3;
        }
    }

    function addLegend(id, groupByTypeSortByMetricMap, groupByCount, groupByCountSum, tp) {
        if(getHearderFor(groupBy) == "timestamp"){
            return;
        }
        let table = "<table style='font-size: 10px;font-weight:bold;'>"
            +"<tr><td style='text-align: left;padding-right: 5px'>"+getHearderFor(sortBy)+"</td><td style='text-align: left;'>"+getHearderFor(groupBy)+"</td></tr>";
        for (let [key, value] of groupByTypeSortByMetricMap){
            let key1 = tmpColorMap.get(key);
            key1=key1.replace("#","_");
            let legend = key;
            if(key == undefined && (groupBy == "msg" || groupBy == "userId" || groupBy == "qTier" || groupBy == "sfdcMsgId")){
                legend =  "NA (non MQ)";
            }

            table += "<tr style='color:"+tmpColorMap.get(key)+"'><td style='padding-right: 3px;width:40px'>"+(100*value/groupByCountSum).toFixed(2) + "%" +"</td><td onclick=\"disableCategory(this,'"+key1+"')\" onmouseout=\"legendMouseOut(this,'"+key1+"','"+tmpColorMap.get(key)+"')\" onmouseover=\"legendMouseOver(this,'"+key1+"')\" title='right click to add to filter' tp='"+tp+ "' class=\"context-menu-two\" style='curson: pointer'>"+legend+"</td></tr>";
        }
        table+="</table>";
        $(id).html(table);
    }

    function drawTimelineChart(filteredTidRequests,minStart,tidSortByMetricMap,groupByTypeSortByMetricMap,groupByCountSum){
        document.getElementById("statetable").innerHTML="<div id='timeLineChart' class='col-lg-12' style='padding: 0 !important;'></div>"
        let xs = {};
        let columns = [];
        let countMax = 6;
        let curI = 0;
        let color = {};

        for (let [type, value1] of groupByTypeSortByMetricMap) {
            if (curI >= countMax) {
                break;
            }
            let legend = "";
            if (type == undefined && (groupBy == "msg" || groupBy == "userId" || groupBy == "qTier" || groupBy == "sfdcMsgId")) {
                legend = (100 * value1 / groupByCountSum).toFixed(2) + "% NA (non MQ)";
            } else {
                legend = (100 * value1 / groupByCountSum).toFixed(2) + "% " + type;
            }
            curI++
            color[type] = tmpColorMap.get(type);
            let series = [];
            let series_x = [];
            let cumulative_map = new Map();
            xs[legend] = legend + "_x";
            series_x.push(legend + "_x");
            series.push(legend);
            for (let [tid, value] of tidSortByMetricMap) {
                for (let index of filteredTidRequests[tid]) {
                    let o = contextData.records[tid][index];
                    if (o.type == 6) {
                        let endObj = o;
                        let prevObj = undefined;
                        let key1 = eval("endObj." + groupBy);
                        if (key1 == type) {
                            for (let curIndex = index + 1; curIndex >= 0; curIndex++) {
                                let curObj = contextData.records[tid][curIndex];
                                if (curObj == undefined || endObj.reqId != curObj.reqId) {
                                    break;//progress signal end
                                }
                                if (curObj.type == 9) {
                                    if (key1 == type) {
                                        if (curObj.epoch > minStart) {
                                            if (prevObj == undefined) {
                                                prevObj = curObj;
                                                if (cumulativeLine == 0) {
                                                    if (cumulative_map.has(curObj.epoch)) {
                                                        cumulative_map.set(curObj.epoch, cumulative_map.get(curObj.epoch) + eval("curObj." + sortBy));
                                                    } else {
                                                        cumulative_map.set(curObj.epoch, eval("curObj." + sortBy));
                                                    }
                                                }
                                            } else {
                                                let diff = eval("curObj." + sortBy) - eval("prevObj." + sortBy);
                                                if (cumulative_map.has(curObj.epoch)) {
                                                    cumulative_map.set(curObj.epoch, cumulative_map.get(curObj.epoch) + diff);
                                                } else {
                                                    cumulative_map.set(curObj.epoch, diff);
                                                }
                                                prevObj = curObj;
                                            }
                                        }
                                    }
                                }
                            }
                            if (prevObj != undefined && prevObj.runTime != endObj.runTime) {
                                if (key1 == type) {
                                    let diff = eval("endObj." + sortBy) - eval("prevObj." + sortBy);
                                    if (cumulative_map.has(endObj.epoch + endObj.runTime)) {
                                        cumulative_map.set(endObj.epoch + endObj.runTime, cumulative_map.get(endObj.epoch + endObj.runTime) + diff);
                                    } else {
                                        cumulative_map.set(endObj.epoch + endObj.runTime, diff);
                                    }
                                }
                            } else if (endObj.runTime < 60000) {//short lived mqfrm < 1 min, no active signals might exist
                                if (key1 == type) {
                                    if (cumulative_map.has(endObj.epoch + endObj.runTime)) {
                                        cumulative_map.set(endObj.epoch + endObj.runTime, cumulative_map.get(endObj.epoch + endObj.runTime) + eval("endObj." + sortBy));
                                    } else {
                                        cumulative_map.set(endObj.epoch + endObj.runTime, eval("endObj." + sortBy));
                                    }
                                }
                            }
                        }
                    } else if (o.type == 2) {
                        let tmpEpoch = o.epoch;
                        let tmpRunTime = o.runTime;
                        let key = eval("o." + groupBy);
                        if (key == type) {
                            let diff = eval("o." + sortBy);
                            if (cumulative_map.has(tmpEpoch + tmpRunTime)) {
                                cumulative_map.set(tmpEpoch + tmpRunTime, cumulative_map.get(tmpEpoch + tmpRunTime) + diff);
                            } else {
                                cumulative_map.set(tmpEpoch + tmpRunTime, diff);
                            }
                        }
                    }
                }
            }
            const tmpSort = new Map([...cumulative_map].sort((a, b) => a[0] - b[0]));
            let tmpValSum = 0;
            let prevTmpTime = 0;
            for (let [tmpTime, tmpVal] of tmpSort) {
                tmpValSum += tmpVal;
                //make series points once every 1000ms to improve chart performance
                if(prevTmpTime == 0 || (tmpTime - prevTmpTime) >= 1000){
                    series.push(tmpValSum);
                    series_x.push(tmpTime);
                    if (cumulativeLine != 0){
                        tmpValSum = 0;
                    }
                    prevTmpTime = tmpTime;
                }
            }
            columns.push(series);
            columns.push(series_x);
        }

        var chart = c3.generate({
            data: {
                xs: xs,
                columns: columns,
                colors: color
            },
            axis: {
                x: {
                    type: "timeseries",
                    localtime: false,
                    tick: {
                        format: function (d) {
                            const time = moment.utc(d);
                            if (time.year() > 1970) {
                                return time.format("HH:mm:ss");
                            }
                            return (time.format("X") / 60).toFixed(2) + "m";
                        },
                        count: 100,
                    }
                },
                y: {
                    label: sortBy
                },
            },
            bindto: document.getElementById("timeLineChart"),
            size: {
                height: 400
            },
            legend: {
                position: 'right'
            },
            subchart: {
                show: true
            },
            point: {
                show: false
            }
        });
        $("#timeLineChart").data('c3-chart',chart);
    }

    function getOrderandType() {
        let tp = -1;
        let order = 1;
        switch (groupBy) {
            case "userId":
                order = 2;
                break;
            case "orgId":
                tp = 0;
                break;
            case "logType":
                tp = 2;
                break;
            case "reqId":
                tp = 3;
                break;
            case "ln":
                tp = 4;
                break;
            case "tn":
                tp = 8;
                break;
            case "none":
                order = 8;
                break;
            case "tid":
                tp = 6;
                break;
            case "racNode":
                tp = 7;
                break;
            case "qTier":
                tp = 9;
                break;
            case "sfdcMsgId":
                tp = 10;
                break;
            case "msg":
                tp = 11;
                break;
            default:
                tp = -1;
                order = 1;
        }
        return [order, tp];
    }



    function getEventTableHeader(groupby){
        let header = "<thead><tr>";
        if(!(groupby == undefined || groupby == "")) {
            header = header + "<th>" + groupby + "</th>";
        }
        if(contextData != undefined && contextData.header != undefined){
            for (let val in contextData.header[customEvent]) {
                const tokens = contextData.header[customEvent][val].split(":");
                if(groupby == undefined || groupby == "" || tokens[1] == "number") {
                    header = header + "<th>" + tokens[0] + "</th>";
                }
            }
        }
        if(!(groupby == undefined || groupby == "")) {
            header = header + "<th>Count</th>";
        }
        header = header + "</tr></thead>";
        return header;
    }

    function addContextHints(){
        let table = "<table style='border-spacing: 5px; border-collapse: separate;'><tr><td id='filter-heading'>Context hints:</td>";
        if(contextData != undefined && contextData.header != undefined){
            for (let val in contextData.header[customEvent]) {
                const tokens = contextData.header[customEvent][val].split(":");
                if(tokens[1] == "text" || tokens[1] == "timestamp") {
                    table += "<td class='all-hints'><a class='send-ga' href=\"javascript:addToFilter('"+tokens[0]+"=xxxx');\" title='Narrows down a filter to a single organisation. For example '"+tokens[0]+"=xxxx' tabindex='-1'>"+tokens[0] +"</a></td>";
                }
            }
        }
        table += "</tr></table>";
        $("#contexthints").html(table);
    }

    function setCustomEvent(){
        if(customEvent == ""){
            //try to get first available
            if(contextData != undefined && contextData.records != undefined){
                for (let value in contextData.records) {
                    customEvent = value;
                    break;
                }
            }
        }
    }

    function isRequestHasFrame(requestArr, entryIndex, event, start, end, addTofilteredStackMap) {
        let flag = false;
        let curIndex = entryIndex;
        //consider all matching requests downward
        while ((flag == false || addTofilteredStackMap) && curIndex >= 0 && requestArr[curIndex].time >= start && requestArr[curIndex].time <= end) {
            if (frameFilterStackMap[event][requestArr[curIndex].hash] !== undefined) {
                flag = true;
                if (isTSView) {
                    if (filteredStackMap[FilterLevel.LEVEL3][tid] == undefined) {
                        filteredStackMap[FilterLevel.LEVEL3][tid] = [];
                    }
                    filteredStackMap[FilterLevel.LEVEL3][tid].push(requestArr[curIndex]);
                }
            }
            curIndex--;
        }
        curIndex = entryIndex + 1;
        //consider all matching samples upward
        while ((flag == false || addTofilteredStackMap) && curIndex < requestArr.length && requestArr[curIndex].time >= start && requestArr[curIndex].time <= end) {
            if (frameFilterStackMap[event][requestArr[curIndex].hash] !== undefined) {
                flag = true;
                if (isTSView) {
                    if (filteredStackMap[FilterLevel.LEVEL3][tid] == undefined) {
                        filteredStackMap[FilterLevel.LEVEL3][tid] = [];
                    }
                    filteredStackMap[FilterLevel.LEVEL3][tid].push(requestArr[curIndex]);
                }
            }
            curIndex++;
        }
        return flag;
    }

    let tidIndex = {};
    let tmpColorMap = new Map();

    function genRequestTable() {
        let start1 = performance.now();
        setCustomEvent();

        if(customEvent == "" || customEvent == undefined){
            return;
        }

        //status graph start
        let downScale = 200;
        let maxEndTimeOfReq = 0;
        let totalRows = 0;
        let rowHeight = 8;
        let filteredTidRequests = {};
        let lineCount = 0;
        if (tableFormat == 2 || tableFormat == 3) {
            tidIndex = {};
        }
        let tmpTidSortByMetricMap = new Map();
        let tmpGgroupByTypeSortByMetricMap = new Map();
        let groupByCount = 0;
        let groupByCountSum = 0;
        //status graph end



        let metricSumMap = {};
        let tidDatalistVal = filterMap["tid"];

        let event = getEventType();

        let headerIndexMap = {};
        let metricsHeaderArray = [];
        let metricsIndexArray = [];
        let groupByIndex = -1;
        let spanIndex = -1;
        let timestampIndex=-1;

        for (let val in contextData.header[customEvent]) {
            const tokens = contextData.header[customEvent][val].split(":");
            if (tokens[1] == "number") {
                metricsIndexArray.push(val);
                metricsHeaderArray.push(tokens[0]);
            }
            if (groupBy == tokens[0]) {
                groupByIndex = val;
            }
            if ("duration" == tokens[0]) { // TODO: take from user
                spanIndex = val;
            }
            if ("timestamp" == tokens[0]) { // TODO: take from user
                timestampIndex = val;
            }
            if (tokens[1] == "text" || tokens[1] == "timestamp") {
                headerIndexMap[tokens[0]] = val;
            }
        }
        metricsHeaderArray.push("Count");

        if(sortBy == "" || sortBy == undefined){
            sortBy = metricsIndexArray[0];
        }

        addContextHints();

        let contextStart = getContextTree(1).context.start;
        let contextTidMap = getContextTree(1).context.tidMap;
        let contextDataRecords = undefined;
        if (contextData != undefined && contextData.records != undefined) {
            contextDataRecords = contextData.records[customEvent];
        }

        table = "<table   style=\"width: 100%;\" id=\"state-table\" class=\"table compact table-striped table-bordered  table-hover dataTable\">" + getEventTableHeader(groupBy);

        //if only frame filter is selected then we need to include stacks that are not part of any requests.
        if(frameFilterString !== "" && tidDatalistVal == undefined && isFilterEmpty(headerIndexMap)){
            for(var tid in contextTidMap){
                if (isTSView) {
                    for (let index = 0; index < contextTidMap[tid].length; index++) {
                        if (frameFilterStackMap[event][contextTidMap[tid][index].hash] !== undefined) {
                            if (filteredStackMap[FilterLevel.LEVEL3][tid] == undefined) {
                                filteredStackMap[FilterLevel.LEVEL3][tid] = [];
                            }
                            filteredStackMap[FilterLevel.LEVEL3][tid].push(contextTidMap[tid][index]);
                        }
                    }
                }
                //generate context table data, need to include requests that has frame filter found stacks
                if(contextDataRecords[tid] != undefined) {
                    let includeTid = false;
                    let reqArray = [];
                    let recordIndex=-1;
                    contextDataRecords[tid].forEach(function (obj) {
                        let record = obj.record;
                        let flag = false;
                        recordIndex++;
                        if (filterMatchNew(record, headerIndexMap)) {
                            let end = record[timestampIndex] - contextStart + record[spanIndex];
                            let start =  record[timestampIndex] - contextStart;
                            try {
                                //do a binary search
                                let entryIndex = isinRequest(contextTidMap[tid], start, end);
                                if (entryIndex != -1) {
                                    let requestArr = contextTidMap[tid];
                                    flag = isRequestHasFrame(requestArr, entryIndex, event, start, end, false);
                                }
                            } catch (err) {
                                //console.log("tid not found in JFR" + tid.key + " " + err.message);
                            }
                        }

                        if (flag) {
                            if ((tableFormat == 2 || tableFormat == 3) && (obj.type == 2 || obj.type == 6)) {
                                includeTid = true;
                                reqArray.push(recordIndex);
                                if ((record[spanIndex] + record[timestampIndex]) > maxEndTimeOfReq) {
                                    maxEndTimeOfReq = record[spanIndex] + record[timestampIndex];
                                }
                                let key = record[groupByIndex];
                                if (!tmpColorMap.has(key)) {
                                    tmpColorMap.set(key, randomColor());
                                    groupByCount++;
                                }
                                let metricValue = record[headerIndexMap[sortBy]];
                                if (metricValue != undefined) {
                                    groupByCountSum += metricValue;
                                } else {
                                    metricValue = 0;
                                }
                                if (tmpGgroupByTypeSortByMetricMap.has(key)) {
                                    tmpGgroupByTypeSortByMetricMap.set(key, tmpGgroupByTypeSortByMetricMap.get(key) + metricValue);
                                } else {
                                    tmpGgroupByTypeSortByMetricMap.set(key, metricValue);
                                }

                                if (tmpTidSortByMetricMap.has(tid)) {
                                    tmpTidSortByMetricMap.set(tid, tmpTidSortByMetricMap.get(tid) + metricValue);
                                } else {
                                    tmpTidSortByMetricMap.set(tid, metricValue);
                                }
                            }
                            if (groupBy == "" || groupBy == undefined) {
                                table = table + "<tr>";
                                for (let field in contextDataRecords[tid].record) {
                                    table = table + "<td>" + contextDataRecords[tid].record[field] + "</td>";
                                }
                                table = table + "</tr>";
                            } else {
                                if (metricSumMap[record[groupByIndex]] == undefined) {
                                    metricSumMap[record[groupByIndex]] = Array(metricsIndexArray.length + 1).fill(0);
                                }

                                for (let i = 0; i < metricsIndexArray.length; i++) {
                                    metricSumMap[record[groupByIndex]][i] += record[metricsIndexArray[i]];
                                }
                                metricSumMap[record[groupByIndex]][metricsIndexArray.length] += 1;
                            }
                        }
                    });
                    if (includeTid) {
                        filteredTidRequests[tid] = reqArray;
                        lineCount++;
                        totalRows++;
                    }
                }
            }
        }else {
            for(var tid in contextDataRecords) {
                let includeTid = false;
                let reqArray = [];
                let recordIndex=-1;
                if (tidDatalistVal == undefined || tidDatalistVal == tid) {
                    contextDataRecords[tid].forEach(function (obj) {
                        let record = obj.record;
                        let flag = false;
                        recordIndex++;
                        if (filterMatchNew(record, headerIndexMap)){
                            flag = true;
                        }

                        //context filter matched, but check if samples of request is matching frame filter
                        if (flag == true && frameFilterString !== "") {
                            flag = false;

                            //check if the request has a stack and if stack is in frameFilterStackMap
                            let end = record[timestampIndex] - contextStart + record[spanIndex];
                            let start =  record[timestampIndex] - contextStart;

                            try {
                                //do a binary search
                                let entryIndex = isinRequest(contextTidMap[tid], start, end);
                                if (entryIndex != -1) {
                                    let requestArr = contextTidMap[tid];
                                    flag = isRequestHasFrame(requestArr, entryIndex, event, start, end, false);
                                }
                            } catch (err) {
                                //console.log("tid not found in JFR" + tid + " " + err.message);
                            }
                        }

                        if (flag) {
                            if ((tableFormat == 2 || tableFormat == 3) && (obj.type == 2 || obj.type == 6)) {
                                includeTid = true;
                                reqArray.push(recordIndex);
                                if ((record[spanIndex] + record[timestampIndex]) > maxEndTimeOfReq) {
                                    maxEndTimeOfReq = record[spanIndex] + record[timestampIndex];
                                }
                                let key = record[groupByIndex];
                                if (!tmpColorMap.has(key)) {
                                    tmpColorMap.set(key, randomColor());
                                    groupByCount++;
                                }
                                let metricValue = record[headerIndexMap[sortBy]];
                                if (metricValue != undefined) {
                                    groupByCountSum += metricValue;
                                } else {
                                    metricValue = 0;
                                }
                                if (tmpGgroupByTypeSortByMetricMap.has(key)) {
                                    tmpGgroupByTypeSortByMetricMap.set(key, tmpGgroupByTypeSortByMetricMap.get(key) + metricValue);
                                } else {
                                    tmpGgroupByTypeSortByMetricMap.set(key, metricValue);
                                }

                                if (tmpTidSortByMetricMap.has(tid)) {
                                    tmpTidSortByMetricMap.set(tid, tmpTidSortByMetricMap.get(tid) + metricValue);
                                } else {
                                    tmpTidSortByMetricMap.set(tid, metricValue);
                                }
                            }
                            if (groupBy == "" || groupBy == undefined) {
                                table = table + "<tr>";
                                for (let field in record) {
                                    table = table + "<td>" + record[field] + "</td>";
                                }
                                table = table + "</tr>";
                            } else {
                                if (metricSumMap[record[groupByIndex]] == undefined) {
                                    metricSumMap[record[groupByIndex]] = Array(metricsIndexArray.length + 1).fill(0);
                                }

                                for (let i = 0; i < metricsIndexArray.length; i++) {
                                    metricSumMap[record[groupByIndex]][i] += record[metricsIndexArray[i]];
                                }
                                metricSumMap[record[groupByIndex]][metricsIndexArray.length] += 1;
                            }
                        }
                    });
                    if(includeTid){
                        filteredTidRequests[tid]=reqArray;
                        lineCount++;
                        totalRows++;
                    }
                }
            }
        }
        let end1 = performance.now();
        console.log("genRequestTable 0 time:" + (end1 - start1) )
        let start = performance.now();
        let [order,tp] = [-1,1] //getOrderandType();
        if (tableFormat == 2 || tableFormat == 3) {
            let minStart=getContextTree(1,EventType.METHOD).context.start; //records are aligned to method profile context start
            let chartWidth = maxEndTimeOfReq - minStart;
            if (chartWidth < 600000) {//min 10 min
                chartWidth = 600000;
            }
            chartWidth = chartWidth / downScale;
            const tidSortByMetricMap = new Map([...tmpTidSortByMetricMap.entries()].sort((a, b) => b[1] - a[1]));
            const groupByTypeSortByMetricMap = new Map([...tmpGgroupByTypeSortByMetricMap.entries()].sort((a, b) => b[1] - a[1]));
            //generate tidIndex for Yaxis
            let index = 0;
            for (let [tid, value] of tidSortByMetricMap){
                tidIndex[index]=tid;
                index++;
            }
            if (tableFormat == 2){
                drowStateChart(filteredTidRequests, chartWidth, downScale, minStart, totalRows * rowHeight, tidSortByMetricMap);
                addLegend("#legendid", groupByTypeSortByMetricMap, groupByCount, groupByCountSum, tp);
                addYAxis("#yaxisid", 0, 0, 0, 17, 0, lineCount, 500, totalRows * rowHeight);
                addXAxis("#xaxisid", 15, 0, 0, 0, 0, chartWidth, chartWidth, 50, minStart, downScale);
            }else{
                drawTimelineChart(filteredTidRequests, minStart, tidSortByMetricMap, groupByTypeSortByMetricMap, groupByCountSum);
            }
        }else{
            if (!(groupBy == "" || groupBy == undefined)) {
                for (let dim in metricSumMap) {
                    table = table + "<tr>";
                    table = table + "<td>" + dim + "</td>";
                    for (let i = 0; i < metricSumMap[dim].length; i++) {
                        table = table + "<td>" + metricSumMap[dim][i] + "</td>";
                    }
                    table = table + "</tr>";
                }
            }
        }

        table = table + "</table>";
        document.getElementById("statetable").innerHTML = table;

        enableDataTable();

        let end = performance.now();
        console.log("genRequestTable 1 time:" )
    }

    function enableDataTable(){
        if(contextTable != undefined) {
            contextTablePage = 0; //reset to 0 except 1st time
        }

        contextTable=$('#state-table').DataTable({
            // "order": [[ order, "desc" ]],
            searching: true,
            "columnDefs": [ {

            } ],
            "drawCallback": function( settings ) {
                if(contextTable != undefined) {
                    //when we change table page focus, remove request selection
                    if ((filterReq != "" && filterReq != undefined) && $("#" + filterReq).length != 0) {
                        updateRequestView();
                    }
                    contextTablePage = contextTable.page.info().page * contextTable.page.len();
                    updateUrl("cpage", contextTablePage, true);
                }
                addClickActionsToFilterTable("state-table");
            },
            "displayStart": contextTablePage,
            aoColumnDefs: [
                {
                    orderSequence: ["desc", "asc"],
                    aTargets: ['_all']
                }
            ],
            "sDom": '<"toolbar">tfp<"clear">'

        });
        $("#statetabledrp").html(getToolBarOptions());
        $("#event-input").on("change", (event) => {
            updateUrl("customEvent",$("#event-input").val(),true);
            customEvent = $("#event-input").val();
            tmpColorMap.clear();
            genRequestTable();
            updateRequestView();
        });

        $("#filter-input").on("change", (event) => {
            updateUrl("groupBy",$("#filter-input").val(),true);
            groupBy = $("#filter-input").val();
            tmpColorMap.clear();
            genRequestTable();
            updateRequestView();
        });
        $("#format-input").on("change", (event) => {
            updateUrl("tableFormat",$("#format-input").val(),true);
            tableFormat = $("#format-input").val();
            genRequestTable();
            updateRequestView();
        });
        $("#sort-input").on("change", (event) => {
            updateUrl("sortBy",$("#sort-input").val(),true);
            sortBy=$("#sort-input").val();
            genRequestTable();
            updateRequestView();
        });
        $("#line-type").on("change", (event) => {
            updateUrl("cumulative",$("#line-type").val(),true);
            cumulativeLine=$("#line-type").val();
            genRequestTable();
            updateRequestView();
        });
        $("#cct-panel").css("height", "100%");
    }

    function getToolBarOptions() {
        let toolBarOptions = 'Event: <select  style="height:30px;text-align: center; " class="filterinput"  name="event-input" id="event-input">\n';
        if(contextData != undefined && contextData.records != undefined){
            for (let value in contextData.records) {
                toolBarOptions += '<option ' + (customEvent == value ? "selected" : "") + " value='" + value + "'>" + value + "</option>\n";
            }
        }
        toolBarOptions += '             </select>';
        toolBarOptions += '&nbsp;&nbsp;Group by: <select  style="height:30px;text-align: center; " class="filterinput"  name="filter-input" id="filter-input">\n';
        toolBarOptions += "<option value=''> ... </option>";
        if(contextData != undefined && contextData.header != undefined){
            for (let val in contextData.header[customEvent]) {
                const tokens = contextData.header[customEvent][val].split(":");
                if(tokens[1] == "text" || tokens[1] == "timestamp") {
                    toolBarOptions += '<option ' + (groupBy == tokens[0] ? "selected" : "") + " value='" + tokens[0] + "'>" + tokens[0] + "</option>\n";
                }
            }
        }
        toolBarOptions += '             </select>' +
            '&nbsp;&nbsp;Format: <select  style="height:30px;text-align: center; " class="filterinput"  name="format-input" id="format-input">\n' +
            '                            <option ' + (tableFormat == 0 ? "selected" : "") + ' value=0>number</option>\n' +
            '                            <option ' + (tableFormat == 1 ? "selected" : "") + ' value=1>percent</option>\n' +
            '                            <option ' + (tableFormat == 2 ? "selected" : "") + ' value=2>thread request view</option>\n' +
            '                            <option ' + (tableFormat == 3 ? "selected" : "") + ' value=3>metric timeline view</option>\n' +
            '                    </select>';
        if (tableFormat == 2 || tableFormat == 3) {
            toolBarOptions += '                        </select>' +
                '&nbsp;&nbsp;Sort by: <select  style="height:30px;text-align: center; " class="filterinput"  name="sort-input" id="sort-input">\n';
            if(contextData != undefined && contextData.header != undefined){
                for (let val in contextData.header[customEvent]) {
                    const tokens = contextData.header[customEvent][val].split(":");
                    if(!(tokens[1] == "text" || tokens[1] == "timestamp")) {
                        toolBarOptions += '<option ' + (sortBy == tokens[0] ? "selected" : "") + " value='" + tokens[0] + "'>" + tokens[0] + "</option>\n";
                    }
                }
            }
            toolBarOptions += '       </select> ';
        }
        if (tableFormat == 3) {
            toolBarOptions += '                        </select>' +
                '&nbsp;&nbsp;Line: <select  style="height:30px;text-align: center; " class="filterinput"  name="line-type" id="line-type">\n' +
                '                            <option ' + (cumulativeLine == 0 ? "selected" : "") + ' value=0>cumulative</option>\n' +
                '                            <option ' + (cumulativeLine == 1 ? "selected" : "") + ' value=1>absolute diff</option>\n' +
                '                            </select> ';
        }
        return toolBarOptions;
    }

    function invertTree(tree) {
        if (tree['tree'] !== undefined) {
            tree = tree['tree'];
        }
        let arr = [];
        var invertTree = getStackFrame("root");
        invert(tree, invertTree, arr, 0);
        invertTree['size'] = tree['size'];
        return invertTree;
    }

    function invert(baseJsonTree, invertTree, arr, size) {
        if (baseJsonTree == null) {
            let frame = invertTree;
            for (let i = arr.length - 1; i > 0; i--) {
                if (i == arr.length - 1) {
                    frame = addFrame(arr[i], size, size, frame);
                } else {
                    frame = addFrame(arr[i], size, 0, frame);
                }
            }
            return 0;
        }
        if (baseJsonTree['children'] == null || baseJsonTree['children'].length == 0) {
            let tmparr = [...arr];
            tmparr.push(baseJsonTree['name']);
            invert(null, invertTree, tmparr, baseJsonTree['size']);
            return baseJsonTree['size'];
        } else {
            let count = 0;
            for (let treeIndex = 0; treeIndex < baseJsonTree['children'].length; treeIndex++) {
                let tmparr = [...arr];
                tmparr.push(baseJsonTree['name']);
                count = count + invert(baseJsonTree['children'][treeIndex], invertTree, tmparr, baseJsonTree['size'])
            }
            if (baseJsonTree['self'] != 0) {
                let frame = invertTree;
                let tmparr = [...arr];
                let diff = baseJsonTree['self'];
                tmparr.push(baseJsonTree['name']);
                for (let i = tmparr.length - 1; i > 0; i--) {
                    if (i == tmparr.length - 1) {
                        frame = addFrame(tmparr[i], diff, diff, frame);
                    } else {
                        frame = addFrame(tmparr[i], diff, 0, frame);
                    }
                }
            }
            return count;
        }
    }

    function getStackFrame(name) {
        try {
            let obj = JSON.parse('{"name":"","size":0,"self":0,"children":[], "map":{}}');
            obj["name"] = name;
            return obj;
        } catch (e) {
            console.log(e.message);
        }
    }

    function addFrame(frameName, size, self, frame) {
        if (frame['map'][frameName] === undefined) {
            frame['map'][frameName] = getStackFrame(frameName);
            frame['children'].push(frame['map'][frameName]);
        }
        frame['map'][frameName]['size'] = frame['map'][frameName]['size'] + size;
        frame['map'][frameName]['self'] = frame['map'][frameName]['self'] + self;
        return frame['map'][frameName];
    }

    //context tree start
    function getStackFrameV1(name) {
        try {
            let obj = JSON.parse('{"nm":"","sz":0,"sf":0,"ch":[], "map":{}}');
            obj["nm"] = name;
            return obj;
        } catch (e) {
            console.log(e.message);
        }
    }

    function addFrameV1(frameName, size, self, frame) {
        if (frame['map'][frameName] === undefined) {
            frame['map'][frameName] = getStackFrameV1(frameName);
            frame['ch'].push(frame['map'][frameName]);
        }
        frame['map'][frameName]['sz'] = frame['map'][frameName]['sz'] + size;
        frame['map'][frameName]['sf'] = frame['map'][frameName]['sf'] + self;
        return frame['map'][frameName];
    }



    function invertTreeV1(tree, num) {
        if (tree['tree'] !== undefined) {
            tree = tree['tree'];
        }
        let arr = [];
        var invertTree = getStackFrameV1("root");
        invertV1(tree, invertTree, arr, 0, num);
        invertTree['sz'] = tree['sz'];
        return invertTree;
    }

    function invertV1(baseJsonTree, invertTree, arr, size, num) {
        if (baseJsonTree == null) {
            let frame = invertTree;
            for (let i = arr.length - 1; i > 0; i--) {
                if (i == arr.length - 1) {
                    frame = addFrameV1(arr[i], size, size, frame);
                } else {
                    frame = addFrameV1(arr[i], size, 0, frame);
                }
            }
            return 0;
        }
        if (compareTree) {
            if ((baseJsonTree['bsz'] !== undefined && num == 1 && baseJsonTree['bsz'] == 0) || (baseJsonTree['csz'] !== undefined && num == 2 && baseJsonTree['csz'] == 0)) { // this was added form compare tree 2
                return 0;
            }
        }
        if (baseJsonTree['ch'] == null || baseJsonTree['ch'].length == 0) {
            let tmparr = [...arr];
            tmparr.push(baseJsonTree['nm']);
            invertV1(null, invertTree, tmparr, baseJsonTree['sz'], num);
            return baseJsonTree['sz'];
        } else {
            let count = 0;
            for (let treeIndex = 0; treeIndex < baseJsonTree['ch'].length; treeIndex++) {
                let tmparr = [...arr];
                tmparr.push(baseJsonTree['nm']);
                count = count + invertV1(baseJsonTree['ch'][treeIndex], invertTree, tmparr, baseJsonTree['sz'], num)
            }
            if (baseJsonTree['sf'] != 0) {
                let frame = invertTree;
                let tmparr = [...arr];
                let diff = baseJsonTree['sf'];
                tmparr.push(baseJsonTree['nm']);
                for (let i = tmparr.length - 1; i > 0; i--) {
                    if (i == arr.length - 1) {
                        frame = addFrameV1(tmparr[i], diff, diff, frame);
                    } else {
                        frame = addFrameV1(tmparr[i], diff, 0, frame);
                    }
                }
            }
            return count;
        }
    }


    function invertTreeV1AtLevel(tree, num) {
        if (tree['tree'] !== undefined) {
            tree = tree['tree'];
        }
        let level = getSelectedLevel(getActiveTree(getEventType(),false));
        let arr = [];
        var invertTree = getStackFrameV1("root");
        invertV1atLevel(tree, invertTree, arr, 0, num, level);
        invertTree['sz'] = tree['sz'];
        //invertTree[level] = tree[level]; // set level size?
        return invertTree;
    }

    function invertV1atLevel(baseJsonTree, invertTree, arr, size, num, level) {
        if(baseJsonTree[level] === undefined || baseJsonTree[level] === 0) {
            return 0;
        }
        if (baseJsonTree == null) {
            let frame = invertTree;
            for (let i = arr.length - 1; i > 0; i--) {
                if (i == arr.length - 1) {
                    frame = addFrameV1(arr[i], size, size, frame);
                } else {
                    frame = addFrameV1(arr[i], size, 0, frame);
                }
            }
            return 0;
        }
        if (compareTree) {
            if ((baseJsonTree['bsz'] !== undefined && num == 1 && baseJsonTree['bsz'] == 0) || (baseJsonTree['csz'] !== undefined && num == 2 && baseJsonTree['csz'] == 0)) { // this was added form compare tree 2
                return 0;
            }
        }
        if (baseJsonTree['ch'] == null || baseJsonTree['ch'].length == 0) {
            let tmparr = [...arr];
            tmparr.push(baseJsonTree['nm']);

            let frame = invertTree;
            for (let i = tmparr.length - 1; i > 0; i--) {
                if (i == 1) {
                    frame = addFrameV1(tmparr[i], baseJsonTree[level], baseJsonTree[level], frame);
                } else {
                    frame = addFrameV1(tmparr[i], baseJsonTree[level], 0, frame);
                }
            }
            return baseJsonTree[level];
        } else {
            let count = 0;
            for (let treeIndex = 0; treeIndex < baseJsonTree['ch'].length; treeIndex++) {
                if(level !== FilterLevel.UNDEFINED){
                    let tmparr = [...arr];
                    tmparr.push(baseJsonTree['nm']);
                    count = count + invertV1atLevel(baseJsonTree['ch'][treeIndex], invertTree, tmparr, baseJsonTree[level], num, level);
                }
            }
            let diff = baseJsonTree[level] - count;
            if (diff > 0) {
                let frame = invertTree;
                let tmparr = [...arr];
                tmparr.push(baseJsonTree['nm']);
                for (let i = tmparr.length - 1; i > 0; i--) {
                    if (i == arr.length - 1) {
                        frame = addFrameV1(tmparr[i], diff, diff, frame);
                    } else {
                        frame = addFrameV1(tmparr[i], diff, 0, frame);
                    }
                }
            }
            return baseJsonTree[level];
        }
    }

    function sortTreeBySize(tree) {
        let ch = tree['ch'];
        if (ch != undefined && ch !== null) {
            for (let index = 0; index < ch.length; index++) {
                sortTreeBySize(ch[index]);
            }
            ch.sort(function (a, b) {
                return b.sz  - a.sz;
            });
        }
    }

    //context tree end

    let prevSelectedLevel = undefined;

    function getSelectedLevel(tree) {
        if(tree === undefined){
            return FilterLevel.UNDEFINED;
        }
        if(tree[FilterLevel.LEVEL3] !== undefined) {
            return FilterLevel.LEVEL3;
        }
        if(tree[FilterLevel.LEVEL2] !== undefined) {
            return FilterLevel.LEVEL2;
        }
        if(tree[FilterLevel.LEVEL1] !== undefined) {
            return FilterLevel.LEVEL1;
        }
        return FilterLevel.UNDEFINED;
    }

    function callTreeWardenAjax(pod, method, endpoint, successFunc) {
        const headers = {};
        return internalWardenAjax(endpoint, method, successFunc, () => {
        }, headers);
    }
    function internalWardenAjax(url, method, successFunc, errorFunc, headers, data, includeCookies = false) {
        let requestObject = {
            url: url,
            type: method,
            success: successFunc,
            error: errorFunc,
            headers: headers,
            xhrFields: { withCredentials: includeCookies }
        };

        if (data !== undefined) {
            requestObject["data"] = data;
            return $.ajax(requestObject);
        }

        return $.ajax(requestObject);
    }

    // update the url with key/value
    function updateUrl(key, value, replace) {
        let newLocation = window.location.href.replace(new RegExp("((\\?|\\&)" + key + "=)[^\\&]*"), '$1' + encodeURIComponent(value));
        if (newLocation.indexOf(key) === -1) {
            const separator = (newLocation.indexOf("?") === -1) ? "?" : "&";
            newLocation = newLocation + separator + key + "=" + encodeURIComponent(value);
        }
        if (replace) {
            window.history.replaceState({}, "", newLocation);
        } else {
            window.history.pushState({}, "", newLocation);
        }
    }

    function validateDateRange(index) {
        const element = document.getElementById("daterange" + index);
        element.style.borderColor = null;
        const daterange = $('#daterange' + index).val().split(" - ");
        const startDate = parseDateTime(daterange[0]);
        const endDate = parseDateTime(daterange[1]);
        const callSubmitDisabled = "setSubmitDisabledX(true);".replace("X", index);

        if (!(startDate.isValid() && endDate.isValid())) {
            toastr_warning("Invalid time range provided, try using format "+dateFormat);
            element.style.borderColor = "red";
            eval(callSubmitDisabled);
            return false;
        }

        if (startDate.isAfter(endDate)) {
            toastr_warning("Start time is after end time");
            element.style.borderColor = "red";
            eval(callSubmitDisabled);
            return false;
        }

        if (endDate.diff(startDate, "seconds") > 60 * 60) {
            toastr_warning("Time ranges are limited to 1 hour. Given " + startDate.format(dateFormat) + " - " + endDate.format(dateFormat));
            element.style.borderColor = "red";
            eval(callSubmitDisabled);
            return false;
        }

        $('#daterange' + index).val(startDate.format(dateFormat) + " - " + endDate.format(dateFormat));
        eval(callSubmitDisabled.replace("true", "false"));
        return true;
    }

    function setContextTree(tree, count, eventType) {
        if (eventType == undefined) {
            eventType = getEventType();
        }
        if (count == 1) {
            contextTree1[eventType] = tree;
        } else {
            contextTree2[eventType] = tree;
        }
    }

    function getContextTree(count, eventType) {
        if (eventType == undefined) {
            eventType = getEventType();
        }

        if(eventType == undefined) {
            return undefined;
        }

        if (count == 1) {
            return contextTree1[eventType];
        } else {
            return contextTree2[eventType];
        }
    }

    function setContextTreeInverted(tree, count, eventType) {
        if (eventType == undefined) {
            eventType = getEventType();
        }
        if (count == 1) {
            contextTreeInverted1[eventType] = tree;
        } else {
            contextTreeInverted2[eventType] = tree;
        }
    }

    function getContextTreeInverted(count, eventType) {
        if (eventType == undefined) {
            eventType = getEventType();
        }

        if(eventType == undefined) {
            return undefined;
        }

        if (count == 1) {
            return contextTreeInverted1[eventType];
        } else {
            return contextTreeInverted2[eventType];
        }
    }

    function setmergedContextTree(tree, eventType) {
        if (eventType == undefined) {
            eventType = getEventType();
        }
        mergedContextTree[eventType] = tree;
    }

    function getmergedContextTree(eventType) {
        if (eventType == undefined) {
            eventType = getEventType();
        }
        if(eventType == undefined) {
            return undefined;
        }
        return mergedContextTree[eventType];
    }

    function setmergedBacktraceTree(tree, eventType) {
        if (eventType == undefined) {
            eventType = getEventType();
        }
        mergedBacktraceTree[eventType] = tree;
    }

    function getmergedBacktraceTree(eventType) {
        if (eventType == undefined) {
            eventType = getEventType();
        }
        if(eventType == undefined) {
            return undefined;
        }
        return mergedBacktraceTree[eventType];
    }

    function setcontextTree1InvertedLevel(tree, eventType, level) {
        if (eventType == undefined) {
            eventType = getEventType();
        }
        if(contextTree1InvertedLevel[eventType] == undefined){
            contextTree1InvertedLevel[eventType] = {};
        }
        contextTree1InvertedLevel[eventType][level] = tree;
    }

    function getcontextTree1InvertedLevel(eventType, level) {
        if (eventType == undefined) {
            eventType = getEventType();
        }
        if(contextTree1InvertedLevel[eventType] != undefined) {
            return contextTree1InvertedLevel[eventType][level];
        }
        return undefined;
    }

    function getActiveTree(eventType, isCT) {
        if (eventType == undefined) {
            eventType = getEventType();
        }

        if (isCT == undefined) {
            isCT = isCalltree;
        }

        if (isCT) {
            if(isJfrContext && !compareTree) {
                let tree = getContextTree(1, eventType);
                if (tree['tree'] !== undefined) {
                    tree =  tree['tree'];
                }
                if(getSelectedLevel(tree) === FilterLevel.UNDEFINED){
                    return getContextTreeInverted(1, eventType);
                }else {
                    return getcontextTree1InvertedLevel(eventType, getSelectedLevel(tree));
                }
            }else {
                return getmergedContextTree();
            }
        } else {
            if(isJfrContext && !compareTree) {
                let tree = getContextTree(1, eventType);
                if (tree['tree'] !== undefined) {
                    return tree['tree'];
                }
                return tree;
            }else {
                return getmergedBacktraceTree();
            }
        }
    }

    function setContextData(data){
        contextData = data;
        processCustomEvents();
    }


    function setContextTreeFrames(frames, count){
        if(count == 1) {
            contextTree1Frames = frames;
        }
    }

    function getContextData() {
        return contextData;
    }

    function processCustomEvents() {
        if(contextData != undefined && contextData.records != undefined){
            for (var customevent in contextData.records) {
                for(var tid in contextData.records[customevent]) {
                    //sort by timestamp
                    contextData.records[customevent][tid].sort(function (a, b) {
                        return a.epoch - b.epoch;
                    });
                }
            }
        }
    }

    // merge trees
    function mergeTrees(contextTreeMaster, contextTreeBranch) {
        const diffJson = breadthFirstDiff(contextTreeMaster, contextTreeBranch);
        if (diffJson.children.length === 0) {
            toastr_warning("Nothing to display");
            //return;
        }
        return diffJson;
    }

    // traverses two context trees diffing their size values
    function breadthFirstDiff(baseJsonTree, canaryJsonTree) {
        const defaultNode = {name: "", bsize: 0, csize: 0, children: []};
        if (baseJsonTree === undefined || canaryJsonTree === undefined) {
            return defaultNode;
        }
        if (baseJsonTree['tree'] !== undefined) {
            baseJsonTree = baseJsonTree['tree'];
        }
        if (canaryJsonTree['tree'] !== undefined) {
            canaryJsonTree = canaryJsonTree['tree'];
        }
        // top level diff
        const mergedTree = {
            name: "root",
            bsize: parseInt((baseJsonTree['size'] === undefined) ? baseJsonTree['total'] : baseJsonTree['size']),
            csize: parseInt((canaryJsonTree['size'] === undefined) ? canaryJsonTree['total'] : canaryJsonTree['size']),
            children: []
        };
        const queue = [];

        const alignedChildren = alignNodes((baseJsonTree['children'] === undefined) ? baseJsonTree['roots'] : baseJsonTree['children'], (canaryJsonTree['children'] === undefined) ? canaryJsonTree['roots'] : canaryJsonTree['children']);

        // populate queue with root level
        addChildrenToQueue(queue, alignedChildren, mergedTree);

        // diff tuples in queue and add children
        while (queue.length !== 0) {
            const diffNode = {name: "", bsize: 0, csize: 0, children: []};
            const treeNodes = queue.shift();

            diffNode.name = (treeNodes[0].name === "") ? treeNodes[1].name : treeNodes[0].name;
            diffNode.bsize = treeNodes[0].size;
            diffNode.csize = treeNodes[1].size;

            treeNodes[2].children.push(diffNode);

            const alignedChildren = alignNodes(treeNodes[0].children, treeNodes[1].children);
            addChildrenToQueue(queue, alignedChildren, diffNode);
        }
        return mergedTree;
    }

    // gets the child elements from the master and branch trees and attaches each pair to the queue
    // along with the level of the tree they will be added
    function addChildrenToQueue(queue, alignedChildren, currentLevel) {
        if (alignedChildren === undefined) {
            return;
        }
        for (let treeIndex = 0; treeIndex < alignedChildren.length; treeIndex++) {
            queue.push([alignedChildren[treeIndex][0], alignedChildren[treeIndex][1], currentLevel]);
        }
    }

    // if both base and canary trees have matching thread names line them up
    function alignNodes(bTreeNode, cTreeNode) {
        const existsInBoth = [];
        const alignedNodes = [];
        const defaultNode = {name: "", size: 0, children: []};
        if (bTreeNode != null) {
            for (const mChild of bTreeNode) {
                if (cTreeNode != null) {
                    for (const bChild of cTreeNode) {
                        if (mChild.name === bChild.name) {
                            existsInBoth.push(mChild.name);
                            alignedNodes.push([mChild, bChild]);
                        }
                    }
                }
            }
        }
        if (bTreeNode != null) {
            for (const mChild of bTreeNode) {
                if (!existsInBoth.includes(mChild.name)) {
                    alignedNodes.push([mChild, defaultNode])
                }
            }
        }
        if (cTreeNode != null) {
            for (const bChild of cTreeNode) {
                if (!existsInBoth.includes(bChild.name)) {
                    alignedNodes.push([defaultNode, bChild])
                }
            }
        }
        alignedNodes.sort(function (a, b) {
            return b[0].size + b[1].size - a[0].size - a[1].size
        });
        return alignedNodes;
    }

    //jfr context start
    // merge trees
    function mergeTreesV1(contextTreeMaster, contextTreeBranch, excludeDepth) {
        if ((isJfrContext) || (compareTree && isJfrContext)) {
            if (contextTreeMaster['merged'] !== undefined) {
                toastr_warning("mergeTreesV1 already done");
            }
            if (contextTreeMaster['tree'] !== undefined) {
                contextTreeMaster = contextTreeMaster['tree'];
            }
            if (contextTreeBranch['tree'] !== undefined) {
                contextTreeBranch = contextTreeBranch['tree'];
            }
            mergeTreesV2(contextTreeMaster, contextTreeBranch);

            updateStackIndex(contextTreeMaster);

            if (contextTreeMaster.ch.length === 0) {
                toastr_warning("Nothing to display");
                //return;
            } else {
                contextTreeMaster.bsz = contextTreeMaster.sz;
                contextTreeMaster.csz = contextTreeBranch.sz;
            }
            contextTreeMaster['merged'] = true;
            return contextTreeMaster;
        } else {
            const diffJson = breadthFirstDiffV1(contextTreeMaster, contextTreeBranch, excludeDepth);
            if (diffJson.children.length === 0) {
                toastr_warning("Nothing to display");
                //return;
            }
            return diffJson;
        }
    }
    function updateStackIndex(contextTreeMaster){
        contextTreeMaster["treeIndex"] = getSelectedLevel(contextTreeMaster);
        if(contextTreeMaster.sm !== undefined && contextTreeMaster.ch !== undefined) {
            for (let index = 0; index < contextTreeMaster.ch.length; index++) {
                if(contextTreeMaster.ch[index].sm !== undefined) {
                    for(var key in contextTreeMaster.ch[index].sm){
                        contextTreeMaster.sm[key] = index;
                    }
                }
            }
        }
    }

    //This will not create an extra tree to merge, memory optimization
    function mergeTreesV2(contextTreeBase, contextTreeCanary) {
        let baseCh = contextTreeBase['ch'];
        let canaryCh = contextTreeCanary['ch'];
        let baseLen = (baseCh !== null) ? baseCh.length : 0;
        let canaryLen = (canaryCh !== null) ? canaryCh.length : 0;

        //sort children based on name
        if (baseCh != null) {
            baseCh.sort(function (a, b) {
                if (a.nm == b.nm) {
                    return 0;
                } else if (a.nm < b.nm) {
                    return -1;
                } else {
                    return 1;
                }
            });
        }
        if (canaryCh != null) {
            canaryCh.sort(function (a, b) {
                if (a.nm == b.nm) {
                    return 0;
                } else if (a.nm < b.nm) {
                    return -1;
                } else {
                    return 1;
                }
            });
        }

        let baseIndex = 0;
        let canaryIndex = 0;
        let appendIndex = baseLen;
        while (baseIndex < baseLen && canaryIndex < canaryLen) {
            if (baseCh[baseIndex]['nm'] == canaryCh[canaryIndex]['nm']) {
                baseCh[baseIndex]['csz'] = canaryCh[canaryIndex]['sz'];
                baseCh[baseIndex]['bsz'] = baseCh[baseIndex]['sz'];
                mergeTreesV2(baseCh[baseIndex], canaryCh[canaryIndex]);//merge recurrsively
                baseIndex++;
                canaryIndex++;
            } else if (baseCh[baseIndex]['nm'] < canaryCh[canaryIndex]['nm']) {
                baseCh[baseIndex]['csz'] = 0;
                baseCh[baseIndex]['bsz'] = baseCh[baseIndex]['sz'];
                sortBaseTreeBySize(baseCh[baseIndex]);//make sure sub tree is sorted by size
                baseIndex++;
            } else if (baseCh[baseIndex]['nm'] > canaryCh[canaryIndex]['nm']) {
                baseCh[appendIndex] = canaryCh[canaryIndex];
                baseCh[appendIndex]['csz'] = canaryCh[canaryIndex]['sz'];
                baseCh[appendIndex]['bsz'] = 0;
                sortCanaryTreeBySize(baseCh[appendIndex]);//make sure sub tree is sorted by size
                appendIndex++;
                canaryIndex++;
            }
        }

        //update remaining baseCh
        for (let index = baseIndex; index < baseLen; index++) {
            baseCh[index]['csz'] = 0;
            baseCh[index]['bsz'] = baseCh[index]['sz'];
            //TODO update all childs bsz to sz and csz to 0
            sortBaseTreeBySize(baseCh[index]);//make sure sub tree is sorted by size
        }

        //append remaining canaryCh to baseCh
        for (let index = canaryIndex; index < canaryLen; index++) {
            if (baseCh === null) {
                baseCh = [];
            }
            baseCh[appendIndex] = canaryCh[index];
            baseCh[appendIndex]['csz'] = canaryCh[index]['sz'];
            baseCh[appendIndex]['bsz'] = 0;
            sortCanaryTreeBySize(baseCh[appendIndex]);//make sure sub tree is sorted by size
            index++;
            appendIndex++;
        }

        //sort merged children based on frame count
        if (baseCh != null) {
            baseCh.sort(function (a, b) {
                return b.bsz + b.csz - a.bsz - a.csz
            });
        }
    }

    function sortBaseTreeBySize(tree) {
        let ch = tree['ch'];
        if (ch != undefined && ch !== null) {
            for (let index = 0; index < ch.length; index++) {
                ch[index]['csz'] = 0;
                ch[index]['bsz'] = ch[index]['sz'];
                sortBaseTreeBySize(ch[index]);
            }
            ch.sort(function (a, b) {
                return b.bsz + b.csz - a.bsz - a.csz
            });
        }
    }

    function sortCanaryTreeBySize(tree) {
        let ch = tree['ch'];
        if (ch != undefined && ch !== null) {
            for (let index = 0; index < ch.length; index++) {
                ch[index]['csz'] = ch[index]['sz'];
                ch[index]['bsz'] = 0;
                sortCanaryTreeBySize(ch[index]);
            }
            ch.sort(function (a, b) {
                return b.bsz + b.csz - a.bsz - a.csz
            });
        }
    }

    // traverses two context trees diffing their size values
    function breadthFirstDiffV1(baseJsonTree, canaryJsonTree, excludeDepth) {
        const defaultNode = {name: "", bsize: 0, csize: 0, children: []};
        if (baseJsonTree === undefined || canaryJsonTree === undefined) {
            return defaultNode;
        }
        if(baseJsonTree['tree'] !== undefined) {
            baseJsonTree = baseJsonTree['tree'];
        }
        if(canaryJsonTree['tree'] !== undefined) {
            canaryJsonTree = canaryJsonTree['tree'];
        }
        // top level diff
        const mergedTree = {
            name: "root",
            bsize: parseInt( baseJsonTree['sz']),
            csize: parseInt(canaryJsonTree['sz']),
            children: []
        };
        const queue = [];

        const alignedChildren = alignNodesV1(baseJsonTree['ch'], canaryJsonTree['ch'], excludeDepth);

        // populate queue with root level
        addChildrenToQueueV1(queue, alignedChildren, mergedTree);

        // diff tuples in queue and add children
        while (queue.length !== 0) {
            const diffNode = {name: "", bsize: 0, csize: 0, children: []};
            const treeNodes = queue.shift();

            diffNode.name = (treeNodes[0].nm === "") ? treeNodes[1].nm : treeNodes[0].nm;
            diffNode.bsize = treeNodes[0].sz;
            diffNode.csize = treeNodes[1].sz;

            treeNodes[2].children.push(diffNode);

            const alignedChildren = alignNodesV1(treeNodes[0].ch, treeNodes[1].ch, 0);
            addChildrenToQueueV1(queue, alignedChildren, diffNode);
        }
        return mergedTree;
    }

    // gets the child elements from the master and branch trees and attaches each pair to the queue
    // along with the level of the tree they will be added
    function addChildrenToQueueV1(queue, alignedChildren, currentLevel) {
        if (alignedChildren === undefined) {
            return;
        }
        for (let treeIndex = 0; treeIndex < alignedChildren.length; treeIndex++) {
            queue.push([alignedChildren[treeIndex][0], alignedChildren[treeIndex][1], currentLevel]);
        }
    }

    // if both base and canary trees have matching thread names line them up
    function alignNodesV1(bTreeNode, cTreeNode, excludeDepth) {
        const existsInBoth = [];
        const alignedNodes = [];
        const defaultNode = {nm: "", sz: 0, ch: []};
        if (bTreeNode != null) {
            for (const mChild of bTreeNode) {
                if (cTreeNode != null) {
                    for (const bChild of cTreeNode) {
                        if((mChild.sz + bChild.sz) > excludeDepth) {
                            if (mChild.nm === bChild.nm) {
                                existsInBoth.push(mChild.nm);
                                alignedNodes.push([mChild, bChild]);
                            }
                        }
                    }
                }
            }
        }
        if (bTreeNode != null) {
            for (const mChild of bTreeNode) {
                if(mChild.sz > excludeDepth) {
                    if (!existsInBoth.includes(mChild.nm)) {
                        alignedNodes.push([mChild, defaultNode])
                    }
                }
            }
        }
        if (cTreeNode != null) {
            for (const bChild of cTreeNode) {
                if(bChild.sz > excludeDepth) {
                    if (!existsInBoth.includes(bChild.nm)) {
                        alignedNodes.push([defaultNode, bChild])
                    }
                }
            }
        }
        alignedNodes.sort(function (a, b) {
            return b[0].sz + b[1].sz - a[0].sz - a[1].sz
        });
        return alignedNodes;
    }
    //jfr context end
</script>


<div id="contextfilter" class="row" >
    <h3 style="width:100%">Context filter</h3>
    <div  id="cct-panel" class="col-lg-12" >
            <span id="filter-view-status" style="color:#F0B778" class="hide"></span>
            <div id="contextpanel"  class="hide" >
                <div id="contexthints" class="row col-lg-12">
                    <table style="border-spacing: 5px; border-collapse: separate;">
                        <tr>
                            <td id="filter-heading">Context hints:</td>

                            <td class="all-hints"><a class="send-ga" href="javascript:addToFilter('org=ORG_ID');"
                                                     title="Narrows down a filter to a single organisation. For example org=00DT0000000Dpvc"
                                                     tabindex="-1">orgId </a>,
                            </td>

                            <td class="sync-hints"><a class="send-ga" href="javascript:addToFilter('user=USR_ID');"
                                                      title="Narrows down a filter to a single user. For example user=0053h000000QKIn"
                                                      tabindex="-1">userId </a>,
                            </td>

                            <td class="sync-hints"><a class="send-ga" href="javascript:addToFilter('log=LOG');"
                                                      title="Narrows down a filter to a single logRecordType. For example log=U"
                                                      tabindex="-1">logRecordType </a>,
                            </td>

                            <td class="all-hints"><a class="send-ga" href="javascript:addToFilter('req=REQ_ID');"
                                                     title="Narrows down a filter to a single reqId. For example req=TID:50095000000082c368"
                                                     tabindex="-1">reqId </a>,
                            </td>

                            <td class="all-hints"><a class="send-ga" href="javascript:addToFilter('frame=FRAME');"
                                                     title="Narrows down a filter to a single frame. For example frame=getNode"
                                                     tabindex="-1">frame </a>,
                            </td>

                            <td class="all-hints"><a class="send-ga" href="javascript:addToFilter('uri=URI');"
                                                     title="Narrows down a filter to a single uri. For example uri=/aura"
                                                     tabindex="-1">uri </a>,
                            </td>

                            <td class="all-hints"><a class="send-ga"
                                                     href="javascript:addToFilter('thread_name=THREAD_NAME');"
                                                     title="Narrows down a filter to a single thread name. For example thread_name=/aura"
                                                     tabindex="-1">thread name </a>,
                            </td>

                            <td class="all-hints"><a class="send-ga" href="javascript:addToFilter('rac=RAC_NODE');"
                                                     title="Narrows down a filter to a single rac node. For example rac=1"
                                                     tabindex="-1">racNode </a>,
                            </td>

                            <td class="sync-hints"><a class="send-ga" href="javascript:addToFilter('trust=TRUST');"
                                                      title="Narrows down a filter to a trust. For example trust=1"
                                                      tabindex="-1">trust </a>,
                            </td>

                            <td class="async-hints"><a class="send-ga" href="javascript:addToFilter('tier=TIER');"
                                                       title="Narrows down a filter to a single queueTier. For example tier=1"
                                                       tabindex="-1">queueTier </a>,
                            </td>

                            <td class="async-hints"><a class="send-ga"
                                                       href="javascript:addToFilter('sfdcmsgid=SFDCMSGID');"
                                                       title="Narrows down a filter to a single sfdcMsgId. For example sfdcmsgid=1"
                                                       tabindex="-1">sfdcMsgId </a>,
                            </td>

                            <td class="all-hints"><a class="send-ga" href="javascript:addToFilter('tid=TID');"
                                                     title="Narrows down a filter to a single tid. For example tid=1234"
                                                     tabindex="-1">tid </a></td>

                        </tr>
                    </table>
                </div>
                <div id="queryfilter-inp-id" class=" form-group row">
                    <div class="col-lg-8">
                        <input type="text" id="queryfilter"
                               class="form-control send-ga"
                               name="queryfilter" title="Query" value=""
                               onkeypress="if(event.keyCode == 13) javascript:applyFilter()"
                        >
                    </div>


                    <div class="col-lg-2">
                        <button id="filter-apply" class="btn btn-block btn-info" type="submit">Apply Filter(s)</button>
                    </div>
                    <div class="col-lg-2">
                        <button id="filter-reset" class="btn btn-block btn-info" type="submit">Reset Filter(s)</button>
                    </div>
                </div>

                <div class="row form-group">


                    <div class="row form-group" id="statetablewrapper" class="statetablewrapper col-lg-12">
                        <div id="statetabledrp" class="statetabledrop col-lg-12">
                        </div>

                        <div id="statetable" class="statetable col-lg-12">
                        </div>
                    </div>
                </div>
                <div class="row">
                    <div class='popup'><span class='popuptext' id='idPopup'>A Simple Popup!</span></div>
                </div>
                <div id="stackncontextview" style="padding-top: 5px; padding-left: 0px;padding-right: 0px;"
                     class="hide stackncontextview col-lg-12">
                    <span id="timelinetitle" style="color: #686A6C;font-family: 'Arial', serif;">Profiling samples collected during request runTime</span>
                    <div style="padding-top:0px; padding-left: 0px;padding-right: 0px;" class="col-lg-12">
                        <div style="padding-top: 0px; padding-left: 0px;padding-right: 5px;padding-bottom: 5px;"
                             class="filterpanel col-lg-9">
                            <div style="border-color: #e5e6e7;  border-width: 1px; border-style: solid;padding-top: 3px; padding-left: 5px;padding-right: 5px;"
                                 class="stackpanel">
                                <div style="overflow: auto;" class="cct-customized-scrollbar threadstate"
                                     id="threadstate">
                                </div>
                                <div class="hackstak" id="stack">
                                </div>
                            </div>
                        </div>
                        <div class="nopadding col-lg-3">
                            <div style="border-color: #e5e6e7;  border-width: 1px; border-style: solid; padding: 5px;"
                                 class="stackcontext" id="stackcontext">
                            </div>
                        </div>
                    </div>
                </div>
            </div>


    </div>
</div>





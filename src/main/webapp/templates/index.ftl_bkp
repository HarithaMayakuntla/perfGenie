<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

    <#--    https://momentjs.com-->
    <script src="/plugins/moment.min.js"></script>

    <#--    https://code.jquery.com/jquery-3.6.1.min.js-->
    <script src="/plugins/jquery-3.6.1.min.js"></script>

    <#--    https://blog.jqueryui.com/2022/07/jquery-ui-1-13-2-released-->
    <script src="/plugins/jquery-ui-1.13.2/jquery-ui.js"></script>
    <link rel="stylesheet" href="/plugins/jquery-ui-1.13.2/jquery-ui.css">

    <#--    https://github.com/xdan/datetimepicker-->
    <script src="/plugins/jquery.datetimepicker.full.min.js"></script>
    <link rel="stylesheet" href="/plugins/jquery.datetimepicker.min.css">

    <#--    https://github.com/twbs/bootstrap/releases/download/v4.2.1/bootstrap-4.2.1-dist.zip-->
    <link rel="stylesheet" href="/plugins/bootstrap-4.2.1/css/bootstrap.min.css">
    <script src="/plugins/bootstrap-4.2.1/js/bootstrap.min.js"></script>

    <link rel="stylesheet" href="/css/profiler.css">
    <script src="/js/input.js"></script>
    <script src="/js/utils.js"></script>

    <script src="/plugins/jquery.contextMenu.min.js"></script>

    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.12.1/css/dataTables.jqueryui.min.css"/>
    <script type="text/javascript" src="https://cdn.datatables.net/1.12.1/js/jquery.dataTables.min.js"></script>
    <script type="text/javascript" src="https://cdn.datatables.net/1.12.1/js/dataTables.jqueryui.min.js"></script>

    <script>
        let threshold = 0.01;
        let treeThreshold = 0.01;
        let levelThreshold = 0;


        $(document).ready(() => {
            isCalltree = urlParams.get('isCalltree') || 'false';
            if(isCalltree == 'false'){isCalltree = false;}
            else{isCalltree = true;}

            if(isCalltree){
                $("#tree-view-type option[value='calltree']").attr("selected", "selected");
            }else {
                $("#tree-view-type option[value='backtrace']").attr("selected", "selected");
            }

            $("#tree-view-type").on("change", (event) => {
                let tree_view_type  = $("#tree-view-type").val();
                if(tree_view_type === "backtrace"){
                    backtrace();
                }else{
                    calltree();
                }
            });

            $("#event-type").on("change", (event) => {
                filterEvent = $("#event-type").val();
                updateUrl("filterEvent",filterEvent,true);
                let note = getNote(filterEvent);
                if(note != ""){
                    $('#cct-note').text(note);
                    $('#cct-note').show();
                }else{
                    $('#cct-note').hide();
                }
                applyFilter();
            });

            console.log(startTime1, endTime1, tenant1, host1, profile1);




            filterEvent = urlParams.get('filterEvent') || 'jdk.ExecutionSample';
            threshold = urlParams.get('threshold') || "0.01";
            threshold = Number(threshold);

            $('#event-type').empty();
            for (var key in jfrprofiles1) {
                if(filterEvent == key) {
                    $('#event-type').append($('<option>', {
                        value: key,
                        text: key,
                        selected: true
                    }));
                }else{
                    $('#event-type').append($('<option>', {
                        value: key,
                        text: key
                    }));
                }
            }

            validateInputAndcreateContextTree(true);

        });

        function resetThreshold(selectedLevel) {
            if (isRefresh) {
                if(selectedLevel === FilterLevel.UNDEFINED) {
                    treeThreshold = Number(document.getElementById("threshold").value);
                }else {
                    levelThreshold = Number(document.getElementById("threshold").value);
                }
            }
            if (selectedLevel === FilterLevel.UNDEFINED) {
                threshold = treeThreshold;
            } else {
                threshold = levelThreshold;
            }
            isRefresh = false;
            document.getElementById("threshold").value = threshold;
        }

        function getEventType() {
            if($("#event-type").val() == null){
                return undefined;
            }
            return $("#event-type").val();
        }

        function validateInputAndcreateContextTree(retry) {
            const dateRanges = [];
            const pods = [];
            const queries = [];
            const profilers = [];
            const tenants = [];
            const hosts = [];
            const profiles = [];
            const uploads = [];
            const fileIds = [];
            const uploadTimes = [];
            const aggregates = [];
            if(startTime1 != undefined && endTime1 != undefined){
                dateRanges.push(startTime1 +" - "+endTime1);
            }
            if(startTime2 != undefined && endTime2 != undefined){
                dateRanges.push(startTime2 +" - "+endTime2);
            }

            profilers.push("Java Flight recorder");
            profilers.push("Java Flight recorder");
            if(tenant1 != undefined){
                tenants.push(tenant1);
            }
            if(tenant2 != undefined){
                tenants.push(tenant2);
            }
            if(host1 != undefined){
                hosts.push(host1);
            }
            if(host2 != undefined){
                hosts.push(host2);
            }
            if(profile1 != undefined){
                profiles.push(profile1);
            }
            if(profile2 != undefined){
                profiles.push(profile2);
            }

            let isValidReq = true;
            for (let i = 0; i < dateRanges.length; i++) {
                if((profiles[i] === "All"  && aggregates[i] === "") || (profiles[i] === "" || hosts[i] === "" || tenants[i] === "")) {
                    isValidReq=false;
                }
            }

            if (profiles.length === 2) {
                compareTree = true;
            }
            if (profilers.length > 0) {
                $("#backtrace").removeClass('hidden');
                if (profilers.length === 2) {
                    if (profilers[0] != profilers[1]) {
                        toastr_warning("Profilers selected must be of same type, selected " + profilers[0] + " and " + profilers[1], null, {
                            timeOut: 0,
                            closeButton: true
                        });
                        return;
                    }
                }
            }

            if(isValidReq && getEventType() != undefined) {
                createContextTree(dateRanges, pods, queries, profilers, tenants, hosts, profiles, uploads, fileIds, uploadTimes, aggregates, true);
            }
        }

        function createJFRCallTree(count) {
            if (count == 1) {
                if (getContextTree(1).context !== undefined && getContextTree(1).context !== null) {
                    isJfrContext = true;

                } else {
                    const defaultResult = {error_messages: [], total: 0, roots: []};
                    setmergedContextTree(mergeTrees(invertTree(getContextTree(1)), defaultResult));
                }
            } else {
                if (getContextTree(1).context !== undefined && getContextTree(1).context !== null && getContextTree(2).context !== undefined && getContextTree(2).context !== null) {
                    isJfrContext = true;
                    setmergedContextTree(mergeTreesV1(invertTreeV1(getContextTree(1), 1), invertTreeV1(getContextTree(2), 2), 1));
                } else {
                    setmergedContextTree(mergeTrees(invertTree(getContextTree(1)), invertTree(getContextTree(2))));
                }
            }
        }

        function createContextTree(dateRanges, pods, queries, profilers, tenants, hosts, profiles, uploads, fileIds, uploadTimes, aggregates, retry) {
            let start = performance.now();
            if (isCalltree == true && profilers[0] != WARDEN_PROFILER && getmergedContextTree() === undefined && getContextTree(1) !== undefined) {
                // this will happen when backtrace view  is loaded and requesting a call tree view
                resetTreeHeader("Inverting tree ...");
                spinnerToggle('spinnerId');
                createJFRCallTree(profiles.length); //generate call tree from back trace

                //apply filter and display tree
                updateProfilerView();
                spinnerToggle('spinnerId');
                let end = performance.now();
                console.log("createContextTree time:" + (end - start));
                return;
            }
            //data not available, retrieve and create context tree
            retrievAndcreateContextTree(dateRanges, pods, queries, profilers, tenants, hosts, profiles, uploads, fileIds, uploadTimes, aggregates, retry, getEventType());
            let end = performance.now();
            console.log("createContextTree time:" + (end - start));
        }

        function retrievAndcreateContextTree(dateRanges, pods, queries, profilers, tenants, hosts, profiles, uploads, fileIds, uploadTimes, aggregates, retry, eventType) {
            let start = performance.now();
            if(getEventType() === eventType) {
                resetTreeHeader("Retrieving tree data ...");
            }
            const queryResults = fetchData(dateRanges, pods, queries, profilers, tenants, hosts, profiles, uploads, fileIds, uploadTimes, aggregates, retry, eventType);
            if (queryResults === undefined) {
                let end = performance.now();
                console.log("retrievAndcreateContextTree 0 time:" + (end - start) + " event:" + eventType);
                return;
            }
            spinnerToggle('spinnerId');

            queryResults.then(contextTrees => {

                let isError = false;

                for (let contextTree of contextTrees) {
                    if (contextTree.hasOwnProperty("error_messages") && contextTree["error_messages"].length > 0) {
                        toastr_warning("Partial results returned. Recommend refreshing the page to retry.", null, {
                            timeOut: 0,
                            closeButton: true
                        });
                    }
                    if (contextTree["error"] != null) {
                        if (contextTree["error"].includes("JFR parser is busy")) {
                            toastr_warning("JFR parser is busy, please try after sometime");
                        } else {
                            toastr_error("Failed to process profile: " + contextTree["error"]);
                        }
                        isError = true;
                    }else if(eventType == "Jstack"){
                        if(contextTree.meta != undefined && contextTree.meta['jstack-interval'] != undefined){
                            let jstackinterval = contextTree.meta['jstack-interval'];
                            $("#event-type option[value='jstack']").html("Java (Thread State(s): All, Sampling Frequency: "+jstackinterval+" s)");
                        }
                    }
                    if (contextTree["meta"] !== undefined && contextTree["meta"] != null && contextTree["meta"]["filename"] !== undefined && contextTree["meta"]["fileid"] !== undefined) {
                        uploadIDMap[contextTree["meta"]["fileid"]] = contextTree["meta"]["filename"];
                    }
                }

                if (isError) {
                    if(getEventType() === eventType) {
                        resetTreeHeader("");
                        let end = performance.now();
                        console.log("retrievAndcreateContextTree 1 time:" + (end - start) + " event:" + eventType);
                    }
                    spinnerToggle('spinnerId');
                    return;
                }

                if (contextTrees.length !== profiles.length) {
                    toastr_error("Failed to get both context trees.");
                    let end = performance.now();
                    console.log("retrievAndcreateContextTree 2 time:" + (end - start) + " event:" + eventType);
                    return;
                }

                if (contextTrees.length === 1) {
                        if (contextTrees[0].context !== undefined && contextTrees[0].context !== null) {
                            //$("#framefilterId").removeClass("hide");
                            isJfrContext = true;
                            const defaultResult = {error_messages: [], sz: 0, ch: []};
                            if(contextTree1Frames == undefined){
                                contextTree1Frames = contextTrees[0].context.frames;
                                contextTree1Frames[3506402] = "root";
                            }
                            /*
                            if (eventType == EventType.METHOD) {
                                contextTree1Frames = contextTrees[0].context.frames;
                                contextTree1Frames[3506402] = "root";
                            }*/
                            if (eventType == "Jstack") {
                                for (var key in contextTrees[0].context.frames) {
                                    if(contextTree1Frames[key] === undefined){
                                        contextTree1Frames[key]=contextTrees[0].context.frames[key];
                                    }
                                }
                            }
                            if (isCalltree) {
                                setContextTree(contextTrees[0], 1, eventType);
                                setContextTreeInverted(invertTreeV1(contextTrees[0], 1), 1, eventType);
                            } else {
                                setContextTree(contextTrees[0], 1, eventType);
                            }
                            contextTrees[0].context.start = Math.round(contextTrees[0].context.start / 1000000);
                            contextTrees[0].context.end = Math.round(contextTrees[0].context.end / 1000000);
                            if (getEventType() == eventType) {
                                if(uploads[0] == "true" && fileIds[0] != "") {
                                    setContextData({"records": {}, "tidlist": []});
                                }else{
                                    getLogContext(dateRanges[0], pods[0], queries[0], profilers[0], tenants[0], profiles[0], hosts[0], uploads[0], fileIds[0], uploadTimes[0], aggregates[0], eventType, contextTrees[0].context.start, contextTrees[0].context.end);
                                }
                                for (var type in jfrprofiles1) {
                                    if(type != eventType) {
                                        retrievAndcreateContextTree(dateRanges, pods, queries, profilers, tenants, hosts, profiles, uploads, fileIds, uploadTimes, aggregates, retry, type);
                                    }
                                }
                            }
                            /*
                            if (eventType == EventType.METHOD) {
                                if(uploads[0] == "true" && fileIds[0] != "") {
                                    updateFilterViewStatus("Note: Context filter is disabled when upload option is selected.");
                                }else{
                                    retrievAndcreateContextTree(dateRanges, pods, queries, profilers, tenants, hosts, profiles, uploads, fileIds, uploadTimes, aggregates, retry, EventType.SOCKET);
                                    retrievAndcreateContextTree(dateRanges, pods, queries, profilers, tenants, hosts, profiles, uploads, fileIds, uploadTimes, aggregates, retry, EventType.APEX);
                                    retrievAndcreateContextTree(dateRanges, pods, queries, profilers, tenants, hosts, profiles, uploads, fileIds, uploadTimes, aggregates, retry, EventType.JSTACK);
                                    retrievAndcreateContextTree(dateRanges, pods, queries, profilers, tenants, hosts, profiles, uploads, fileIds, uploadTimes, aggregates, retry, EventType.NATIVE);
                                }
                                //retrievAndcreateContextTree([contextTrees[0].context.start+" - "+contextTrees[0].context.end], pods, queries, profilers, tenants, hosts, profiles, uploads, fileIds, uploadTimes, aggregates, retry, EventType.JSTACK);
                            }*/
                        } else {
                            $("#framefilterId").addClass("hide");
                            const defaultResult = {error_messages: [], size: 0, children: []};
                            if (isCalltree) {
                                setmergedContextTree(mergeTrees(invertTree(contextTrees[0]), defaultResult), eventType);
                            } else {
                                setContextTree(contextTrees[0], 1, eventType);//cache to generate backtrave view
                                setmergedBacktraceTree(mergeTrees(contextTrees[0], defaultResult), eventType);
                            }
                        }
                } else {
                    $("#framefilterId").addClass("hide");
                        if (contextTrees[0].context !== undefined && contextTrees[1].context !== undefined && contextTrees[0].context !== null && contextTrees[1].context !== null) {
                            isJfrContext = true;
                            if(contextTree1Frames == undefined){
                                contextTree1Frames = contextTrees[0].context.frames;
                                contextTree1Frames[3506402] = "root";
                            }
                            if(contextTree2Frames == undefined){
                                contextTree2Frames = contextTrees[1].context.frames;
                            }

                            if (eventType == "Jstack") {
                                for (var key in contextTrees[0].context.frames) {
                                    if(contextTree1Frames[key] === undefined){
                                        contextTree1Frames[key]=contextTrees[0].context.frames[key];
                                    }
                                }
                                for (var key in contextTrees[1].context.frames) {
                                    if(contextTree2Frames[key] === undefined){
                                        contextTree2Frames[key]=contextTrees[1].context.frames[key];
                                    }
                                }
                            }

                            if (isCalltree) {
                                setmergedContextTree(mergeTreesV1(invertTreeV1(contextTrees[0], 1), invertTreeV1(contextTrees[1], 2), 1), eventType);
                            } else {
                                setContextTree(contextTrees[0], 1, eventType);
                                setContextTree(contextTrees[1], 2, eventType);
                                setmergedBacktraceTree(mergeTreesV1(contextTrees[0], contextTrees[1], 1), eventType);
                            }
                            console.log("Skipping context data for compare tree");
                            updateFilterViewStatus("Note: Context filter is disabled when compare option selected.");
                            unhideFilterViewStatus();

                            if (eventType == getEventType()) {
                                for (var type in jfrprofiles1) {
                                    if(type != eventType) {
                                        retrievAndcreateContextTree(dateRanges, pods, queries, profilers, tenants, hosts, profiles, uploads, fileIds, uploadTimes, aggregates, retry, type);
                                    }
                                }
                            }
                        } else {
                            if (isCalltree) {
                                setmergedContextTree(mergeTrees(invertTree(contextTrees[0]), invertTree(contextTrees[1])), eventType);
                            } else {
                                setContextTree(contextTrees[0], 1, eventType);//cache to generate backtrave view
                                setContextTree(contextTrees[1], 2, eventType);//cache to generate backtrave view
                                setmergedBacktraceTree(mergeTrees(contextTrees[0], contextTrees[1]), eventType);
                            }
                        }

                }
                if (!isJfrContext) {
                    updateProfilerView();
                } else if (getEventType() == eventType) {
                    updateProfilerView();
                }
                spinnerToggle('spinnerId');
            }).catch(error => {
                let end = performance.now();
                console.log("retrievAndcreateContextTree 4 time:" + (end - start) + " event:" + eventType);
                if (retry) {
                    console.log("retry retrievAndcreateContextTree " + eventType + " error: "+error.stack);
                    retrievAndcreateContextTree(dateRanges, pods, queries, profilers, tenants, hosts, profiles, uploads, fileIds, uploadTimes, aggregates, false, eventType);
                } else {
                    console.error(error);
                    toastr_error("Failed to load data for the calling context tree.");
                }
                spinnerToggle('spinnerId');
            });
            let end = performance.now();
            console.log("retrievAndcreateContextTree 5 time:" + (end - start) + " event:" + eventType);
        }

        function getLogContext(timeRange, pod, query, profiler, tenant, profile, host, upload, fileId, uploadTime, aggregate, eventType, start, end) {
            //setContextData({records:{},tidlist:[]});
            //console.log("getLogContext skipped");
            //return;

            unhideFilterViewStatus();
            updateFilterViewStatus("Note: Retrieving request context from jfr, this may take few sec  ...");
            const callTreeUrl = getCallTreeUrl(timeRange, pod, query, profiler, tenant, profile, host, upload, fileId, uploadTime, aggregate, "customevent");
            let toTenant = tenant;
            if(isS3 == "true") {
                toTenant = "";
            }
            let request = wardenAjax(toTenant, "GET", callTreeUrl, function (response) { // success function
                console.log("getLogContext done");
                if(response === "") {
                    console.log("log context not available in JFR, will fetch from Splunk");
                    updateFilterViewStatus("Note: Failed to get Request context.");
                    toastr_warning("Failed to get Request context.");
                    setContextData({records:{},tidlist:[]});
                }else {
                    if(response.tidlist == undefined && response.error != undefined){
                        updateFilterViewStatus("Note: Failed to get Request context.");
                        toastr_warning("Failed to get Request context.");
                        setContextData({records:{},tidlist:[]});
                    }else {
                        setContextData(response);
                        showContextFilter();
                        hideFilterViewStatus();
                        refreshTree();
                    }
                }
            }, function (error) {
                setContextData({records:{},tidlist:[]});
                updateFilterViewStatus("Note: Failed to get Request context.");
                toastr_warning("Failed to get Request context.");
                console.error(error);
            });
        }

        function createCCTModal(modalId, data) {
            $('#modals-guid')[0].innerHTML = "<div   id='" + modalId + "' class='modal fade' tabindex='-1' role='dialog' aria-labelledby='cctmodel' aria-hidden='true'>" +
                "<div class='modal-dialog' style=\"max-width: 95%;\" role=\"document\">" +
                    "<div class='modal-content'>" +
                    "<div id='data-modal-body' class='modal-body' style='overflow: auto'>" +
                        "<ul class='tree'>" +
                            "<li>" + data + "</li>" +
                        "</ul>"+
                    "</div>" +
                    "</div>" +
                "</div>" +
            "</div>";
        }


        function loadCCTModal(modalId) {
            $('#' + modalId).modal('show');
            addClickActionsToElement($('#modals-guid')[0]);
        }

        function unLoadCCTModal(modalId) {
            $('#'+modalId).modal('hide');
        }


        function getNote(eventType){
            if(eventType == "socket"){
                return "Note: socket R/W events are captured only when R/W operation takes more than 200 ms";
            }
            return "";
        }

        function refreshTree() {
            isRefresh = true;
            updateProfilerView();
        }

        //create html tree recursively
        function updateProfilerView(level) {

            if (level == undefined) {
                level = FilterLevel.LEVEL1;
            }


            let start = performance.now();
            if (!filterToLevel(level)) {
                let end = performance.now();
                console.log("filterToLevel time:" + (end - start));
                return;
            }
            let end = performance.now();
            console.log("filterToLevel time:" + (end - start));


            let treeToProcess = getActiveTree(getEventType(), isCalltree);
            let selectedLevel = getSelectedLevel(getActiveTree(getEventType(), false));

            if (currentLoadedTree === treeToProcess && prevOption === currentOption && isRefresh === false && isLevelRefresh === false && prevSelectedLevel === selectedLevel) {
                console.log("no change in tree, option:" + prevOption +":"+isRefresh+":"+":"+isLevelRefresh+":"+selectedLevel);
                end = performance.now();
                console.log("updateProfilerView 1 time:" + (end - start));
                return;
            }
            currentLoadedTree = treeToProcess;
            prevOption = currentOption;
            prevSelectedLevel = selectedLevel;
            isLevelRefresh = false;

            resetThreshold(selectedLevel);

            let graphType = isCalltree ? "Call tree view" : "Backtrace view";

            // if no data returned from our call don't try to parse it
            if (treeToProcess === undefined) {
                end = performance.now();
                console.log("updateProfilerView 2 time:" + (end - start));
                return;
            }

            let timeRange = "";
            if (compareTree) {
                    let $profile1 = "";
                    let $profile2 = "";

                        $profile1 = $("#bases1 :selected").text();


                        $profile2 = $("#bases2 :selected").text();

                    timeRange = ", Profile(s): <span class=\"bclr\">" + $profile1 + "</span> <span class=\"tclr\">" + $profile2 + "</span>";

            } else {

                    timeRange = ", Profile: <span>" + $("#bases1 :selected").text() + "</span>";
            }

            if(isJfrContext && !compareTree) {
                resetTreeHeader("<span style=\"font-weight:bold\">" + graphType + "</span>," + " Total samples: "
                + treeToProcess.sz + ", <span title=\"Exclude samples below threshold %\">Threshold</span>: " + threshold + timeRange + (isAggregation() ? getTextForAggregationInput(contextTree1["1"]) : ""));
            }else{
                resetTreeHeader("<span style=\"font-weight:bold\">" + graphType + "</span>," + " Total samples: "
                + ( ((treeToProcess.bsize !== undefined) ? treeToProcess.bsize : treeToProcess.bsz ) + ((treeToProcess.csize !== undefined) ? treeToProcess.csize : treeToProcess.csz)) + ", <span title=\"Exclude samples below threshold %\">Threshold</span>: "
                + threshold + timeRange);
            }

            if ( compareTree && isJfrContext ) {
                showTreeV1Compare(treeToProcess);
            }else if(isJfrContext && selectedLevel !== FilterLevel.UNDEFINED) {
                if(!isCalltree) {
                    sortTreeLevelBySize(treeToProcess, selectedLevel);
                    //updateStackIndex(treeToProcess);
                    showTreeV1Level(treeToProcess, selectedLevel);
                }else{
                    sortTreeBySize(treeToProcess);
                    showTreeV1(treeToProcess);
                }
            }else if(isJfrContext) {
                sortTreeBySize(treeToProcess);
                showTreeV1(treeToProcess);
            } else {
                showTree(treeToProcess);
            }
            addClickActionsToElement(document);
            if (!compareTree) {
                $(".img-swap").each(function () {
                    this.src = this.src.replace("_on", "_off");
                });
            }
            end = performance.now();
            console.log("updateProfilerView 3 time:" + (end - start));
        }

        function showTree(treeToProcess) {
            treeHtml = "";
            let skip = false;
            let index = 0;
            treeToProcess.children.forEach(function (root) {
                if (skip || isSkipSubtree(root.bsize, root.csize)) {
                    return;
                }
                if ((100 * (root.bsize) / (treeToProcess.bsize + treeToProcess.csize) < Number(threshold)) && (100 * (root.csize) / (treeToProcess.bsize + treeToProcess.csize) < Number(threshold))) {
                    if (treeToProcess.bsize > 1 || treeToProcess.csize > 1) {
                        treeHtml = treeHtml + "<li>...\n";
                    }
                    skip = true;
                } else if (treeToProcess.children.length > 0) {
                    treeHtml = treeHtml + getLi(root.bsize, root.csize, treeToProcess.bsize + treeToProcess.csize, root.name, 0, index);
                    treeHtml = treeHtml + "<ul><li></ul>\n";
                }
                index++;
            });
            $("ul.tree").html(treeHtml);
        }

        function showTreeV1Level(treeToProcess, level) {
            treeHtml = "";
            let skip = false;
            let index = 0;
            treeToProcess.ch.forEach(function (root) {
                if (skip || root[level] === undefined || root[level] === 0 || isSkipSubtree(root[level], 0)) {
                    return;
                }
                if ((100 * (root[level]) / (treeToProcess.sz) < Number(threshold)) && (100 * (root[level]) / (treeToProcess.sz) < Number(threshold))) {
                    if (treeToProcess[level] > 1) {
                        treeHtml = treeHtml + "<li>...\n";
                    }
                    skip = true;
                } else if (treeToProcess.ch.length > 0) {
                    treeHtml = treeHtml + getLi(root[level], 0, treeToProcess.sz, root.nm, 0, index);
                    treeHtml = treeHtml + "<ul><li></ul>\n";
                }
                index++;
            });
            $("ul.tree").html(treeHtml);
        }

        function showTreeV1(treeToProcess, level) {
            treeHtml = "";
            let skip = false;
            let index = 0;
            treeToProcess.ch.forEach(function (root) {
                if (skip || isSkipSubtree(root.sz, 0)) {
                    return;
                }
                if ((100 * (root.sz) / (treeToProcess.sz) < Number(threshold)) && (100 * (root.sz) / (treeToProcess.sz) < Number(threshold))) {
                    if (treeToProcess.sz > 1) {
                        treeHtml = treeHtml + "<li>...\n";
                    }
                    skip = true;
                } else if (treeToProcess.ch.length > 0) {
                    treeHtml = treeHtml + getLi(root.sz, 0, treeToProcess.sz, root.nm, 0, index);
                    treeHtml = treeHtml + "<ul><li></ul>\n";
                }
                index++;
            });
            $("ul.tree").html(treeHtml);
        }

        function showTreeV1Compare(treeToProcess) {
            treeHtml = "";
            let skip = false;
            let index = 0;
            treeToProcess.ch.forEach(function (root) {
                if (skip || isSkipSubtree(root.bsz, root.csz)) {
                    return;
                }
                if ((100 * (root.bsz) / (treeToProcess.bsz + treeToProcess.csz) < Number(threshold)) && (100 * (root.csz) / (treeToProcess.bsz + treeToProcess.csz) < Number(threshold))) {
                    if (treeToProcess.bsz > 1 || treeToProcess.csz > 1) {
                        treeHtml = treeHtml + "<li>...\n";
                    }
                    skip = true;
                } else if (treeToProcess.ch.length > 0) {
                    treeHtml = treeHtml + getLi(root.bsz, root.csz, treeToProcess.bsz + treeToProcess.csz, root.nm, 0, index);
                    treeHtml = treeHtml + "<ul><li></ul>\n";
                }
                index++;
            });
            $("ul.tree").html(treeHtml);
        }

        function searchWord(root, word) {
            let skip = false;
            if(root.children !== undefined) {
                root.children.forEach(function (child) {
                    if(skip == false) {
                        if (getFrameName(child.name).includes(word)) {
                            skip = true;
                        } else {
                            skip = searchWord(child, word);
                        }
                    }
                });
            }else {
                if(root.ch !== null) {
                    root.ch.forEach(function (child) {
                        if (skip == false) {
                            if (getFrameName(child.nm).includes(word)) {
                                skip = true;
                            } else {
                                skip = searchWord(child, word);
                            }
                        }
                    });
                }
            }
            return skip;
        }

        function initSearchTree(word) {
            let treeToProcess;

            treeToProcess = getActiveTree(getEventType(), isCalltree);

            // if no data returned from our call don't try to parse it
            if (treeToProcess === undefined) {
                return;
            }

            const tree = document.querySelectorAll('li.expand');
            if (treeToProcess.children !== undefined) {
                for (let i = 0; i < tree.length; i++) {
                    if (searchWord(treeToProcess.children[Number(tree[i].getAttribute('index'))], word)) {
                        expandTree(Number(tree[i].getAttribute('index')), tree[i]);
                    }
                }
            } else {
                for (let i = 0; i < tree.length; i++) {
                    if (searchWord(treeToProcess.ch[Number(tree[i].getAttribute('index'))], word)) {
                        expandTree(Number(tree[i].getAttribute('index')), tree[i]);
                    }
                }
            }
            if (!compareTree) {
                $(".img-swap").each(function () {
                    this.src = this.src.replace("_on", "_off");
                });
            }
        }

        function isSkipSubtree(bsize, csize) {
            if ((bsize === 0 && currentOption === 2) || (csize === 0 && currentOption === 3)) {
                return true;
            }
            return false;
        }

        function expandTree(index, element) {

            let treeToProcess = getActiveTree(getEventType(), isCalltree); //getTreeToProcess();

            // if no data returned from our call don't try to parse it
            if (treeToProcess === undefined) {
                return;
            }

            let selectedLevel = getSelectedLevel(treeToProcess);

            treeHtml = "";
            if (compareTree && isJfrContext) {
                if (!processChildV1Compare(treeToProcess.ch[index], treeToProcess.bsz + treeToProcess.csz, 1)) {
                    treeHtml = treeHtml + "<li>...\n";
                }
            }else if(isJfrContext && selectedLevel !== FilterLevel.UNDEFINED) {
                if (!processChildV1Level(treeToProcess.ch[index], treeToProcess.sz, 1, selectedLevel)) {
                    treeHtml = treeHtml + "<li>...\n";
                }
            }else if (isJfrContext) {
                if (!processChildV1(treeToProcess.ch[index], treeToProcess.sz, 1)) {
                    treeHtml = treeHtml + "<li>...\n";
                }
            } else{
                if (!processChild(treeToProcess.children[index], treeToProcess.bsize + treeToProcess.csize, 1)) {
                    treeHtml = treeHtml + "<li>...\n";
                }
            }
            element.getElementsByTagName("ul")[0].innerHTML = treeHtml;
            addClickActionsToElement(element.getElementsByTagName("ul")[0]);
        }

        function processChildV1Level(tree, total, depth, level) {
            //skip sub tree for below given threshold
            if (100 * tree[level] / total < Number(threshold)) {
                return false;
            }
            let skip = false;

            if (tree.ch == null) {
                tree.ch = [];
            }

            tree.ch.forEach(function (child) {
                if (skip || child[level] === undefined || child[level] === 0 || isSkipSubtree(child[level], 0)) {
                    return;
                }
                if (100 * child[level] / total < Number(threshold)) {
                    treeHtml = treeHtml + "<li>...\n";
                    skip = true;
                } else if (tree.ch.length > 0) {
                    treeHtml = treeHtml + getLi(child[level], 0, total, child.nm, depth, 0);
                    treeHtml = treeHtml + "<ul>\n";
                    if (!processChildV1Level(child, total, depth + 1, level)) {
                        treeHtml = treeHtml + "<li>...\n";
                    }
                    treeHtml = treeHtml + "</ul>\n";
                }
            });
            return true;
        }

        function processChildV1(tree, total, depth) {
            //skip sub tree for below given threshold
            if (100 * tree.sz / total < Number(threshold)) {
                return false;
            }
            let skip = false;

            if(tree.ch == null) {
                tree.ch = [];
            }

            tree.ch.forEach(function (child) {
                if (skip || isSkipSubtree(child.sz, 0)) {
                    return;
                }
                if (100 * child.sz / total < Number(threshold)) {
                    treeHtml = treeHtml + "<li>...\n";
                    skip = true;
                } else if (tree.ch.length > 0) {
                    treeHtml = treeHtml + getLi(child.sz, 0, total, child.nm, depth, 0);
                    treeHtml = treeHtml + "<ul>\n";
                    if (!processChildV1(child, total, depth + 1)) {
                        treeHtml = treeHtml + "<li>...\n";
                    }
                    treeHtml = treeHtml + "</ul>\n";
                }
            });
            return true;
        }

        function processChildV1Compare(tree, total, depth) {
            //skip sub tree for below given threshold
            if ((100 * (tree.bsz) / total < Number(threshold)) && (100 * ((tree.csz !== undefined) ? tree.csz : 0) / total < Number(threshold))) {
                return false;
            }
            let skip = false;

            if (tree.ch == null) {
                tree.ch = [];
            }

            tree.ch.forEach(function (child) {
                if (skip || isSkipSubtree(child.bsz, ((child.csz !== undefined) ? child.csz : 0))) {
                    return;
                }
                if (100 * (child.bsz + ((child.csz !== undefined) ? child.csz : 0)) / total < Number(threshold)) {
                    treeHtml = treeHtml + "<li>...\n";
                    skip = true;
                } else if (tree.ch.length > 0) {
                    treeHtml = treeHtml + getLi(child.bsz, ((child.csz !== undefined) ? child.csz : 0), total, child.nm, depth, 0);
                    treeHtml = treeHtml + "<ul>\n";
                    if (!processChildV1Compare(child, total, depth + 1)) {
                        treeHtml = treeHtml + "<li>...\n";
                    }
                    treeHtml = treeHtml + "</ul>\n";
                }
            });
            return true;
        }

        function processChild(tree, total, depth) {
            //skip sub tree for below given threshold
            if ((100 * (tree.bsize) / total < Number(threshold)) && (100 * (tree.csize) / total < Number(threshold))) {
                return false;
            }
            let skip = false;

            tree.children.forEach(function (child) {
                if (skip || isSkipSubtree(child.bsize, child.csize)) {
                    return;
                }
                if (100 * (child.bsize + child.csize) / total < Number(threshold)) {
                    treeHtml = treeHtml + "<li>...\n";
                    skip = true;
                } else if (tree.children.length > 0) {
                    treeHtml = treeHtml + getLi(child.bsize, child.csize, total, child.name, depth, 0);
                    treeHtml = treeHtml + "<ul>\n";
                    if (!processChild(child, total, depth + 1)) {
                        treeHtml = treeHtml + "<li>...\n";
                    }
                    treeHtml = treeHtml + "</ul>\n";
                }
            });
            return true;
        }

        function getLi(bsize, csize, total, name, depth, index) {
            let color = "black";
            let compareDiff = "";
            let toolTip = "";
            let diffPercent = "NA";
            let bar = "";
            if (compareTree) {
                if (bsize === 0) {
                    color = "tclr";
                } else if (csize === 0) {
                    color = "bclr"
                }

                if (bsize > 0 && csize > 0) {
                    diffPercent = (100 * (csize - bsize) / bsize).toFixed(2);
                    if (diffPercent > 0) {
                        bar = "<div title=\"% diff \" class = \"rbar\" style=\"width:" + Math.log(diffPercent) * 2 + "px;\">&nbsp;</div>";
                    } else {
                        bar = "<div title=\"% diff\" class = \"ibar\" style=\"width:" + Math.log(Math.abs(diffPercent)) * 2 + "px;\">&nbsp;</div>";
                    }
                    diffPercent = " diff percent: " + diffPercent + " %";
                }
                compareDiff = "<span class=\"bclr\">" + (100 * (bsize) / total).toFixed(2) + "% </span>" + "<span class=\"tclr\">" + (100 * (csize) / total).toFixed(2) + "%&nbsp;</span>";

                toolTip = "base: " + bsize + " new: " + csize + " diff: " + (csize - bsize) + diffPercent;
            } else {
                compareDiff = (100 * (bsize + csize) / total).toFixed(2) + "% " + (bsize + csize);
            }

            let tmpClass = "";
            if (depth == 0) {
                tmpClass = " class=\"expand\" index=" + index + " ";
            }
            if (isJfrContext == true) {
                return "<li" + tmpClass + "><div class=\"subtree\">[" + depth + "] " + compareDiff + " </div>" + bar + "<span title=\"" + toolTip + "\" class=\"" + color + "\">&nbsp;" + getFrameName(name) + "</span>\n";
            } else {
                return "<li" + tmpClass + "><div class=\"subtree\">[" + depth + "] " + compareDiff + " </div>" + bar + "<span title=\"" + toolTip + "\" class=\"" + color + "\">&nbsp;" + name + "</span>\n";
            }
        }

        // [ajax request(s)] gets context tree data
        function fetchData(dateRanges, pods, queries, profilers, tenants, hosts, profiles, uploads, fileIds, uploadTimes, aggregates, retry, eventType) {
            const requests = [];
            let datacenters = [];
            for (let i = 0; i < tenants.length; i++) {
                if (tenants[i].includes(".")) {
                    datacenters[i] = tenants[i].split(".")[0].trim();
                    tenants[i] = tenants[i].split(".")[1].trim();
                }else {
                    datacenters[i] = tenants[i];
                }
            }
            let toTenant = "";
            if (profilers[0] == WARDEN_PROFILER) {
                toTenant = pods[0];
            } else if (uploads[0] != "true" && isS3 == "false") {
                toTenant = datacenters[0];
            }
            const callTreeUrl = getCallTreeUrl(dateRanges[0], pods[0], queries[0], profilers[0], tenants[0], profiles[0], hosts[0], uploads[0], fileIds[0], uploadTimes[0], aggregates[0], eventType);
            if (retry) {
                requests.push(callTreeWardenAjax(toTenant, "GET", callTreeUrl, result => result));
            } else {
                requests.push(callTreeWardenAjax(toTenant, "GET", callTreeUrl, result => result));
            }
            if (profiles.length === 2) {
                let toTenant = "";
                if (profilers[1] == WARDEN_PROFILER) {
                    toTenant = pods[1];
                } else if (uploads[1] != "true" && isS3 == "false") {
                    toTenant = datacenters[1];
                }
                const callTreeUrl = getCallTreeUrl(dateRanges[1], pods[1], (queries.length === 2) ? queries[1] : '', (profilers.length === 2) ? profilers[1] : '', (tenants.length === 2) ? tenants[1] : '', (profiles.length === 2) ? profiles[1] : '', (hosts.length === 2) ? hosts[1] : '', (uploads.length === 2) ? uploads[1] : '', (fileIds.length === 2) ? fileIds[1] : '', (uploadTimes.length === 2) ? uploadTimes[1] : '', aggregates[1], eventType);
                if (retry) {
                    requests.push(callTreeWardenAjax(toTenant, "GET", callTreeUrl, result => result));
                } else {
                    requests.push(callTreeWardenAjax(toTenant, "GET", callTreeUrl, result => result));
                }
            }
            return Promise.all(requests);
        }

        // the url to get calling context trees
        function getCallTreeUrl(timeRange, pod, query, profiler, tenant, profile, host, upload, fileId, uploadTime, aggregate, eventType) {
            // for debug console.log("getCallTreeUrl timeRange:" + timeRange + " pod:" + pod + " query:"+query + " profiler:" + profiler + " tenant:"+tenant + " profile:" + profile + " host:" + host + " upload:" + upload + " fileId:" + fileId + " uploadTime:" + uploadTime + " aggregate:" + aggregate)
            let endpoint = "";
            {
                    if(eventType == "Jstack") {
                        const start = parseInt(timeRange.split(" - ")[0]);
                        const end = parseInt(timeRange.split(" - ")[1]);
                        endpoint = "/v1/profile/" + tenant + "/jstack?start=" + start + "&end=" + end +
                            "&metadata_query=" + encodeURIComponent("host=" + host) +
                            "&metadata_query=" + encodeURIComponent("tenant=" + tenant) +
                            "&metadata_query=" + encodeURIComponent("name=Jstack");
                        return endpoint;
                    }
                    if (profile !== "All") {
                        let array = profile.split(" - ");
                        const timestamp = array[0];
                        let guid = array[1];
                        endpoint = "/v1/profile/" + tenant + "/?start=" + timestamp + "&end=" + timestamp +
                            "&metadata_query=" + encodeURIComponent("host=" + host) +
                            "&metadata_query=" + encodeURIComponent("tenant=" + tenant) +
                            "&metadata_query=" + encodeURIComponent("guid=" + guid) +
                            "&metadata_query=" + encodeURIComponent("name=" + eventType);
                    } else {
                        const start = parseInt(timeRange.split(" - ")[0]);
                        const end = parseInt(timeRange.split(" - ")[1]);
                        endpoint = "/v1/profile/" + tenant + "/?start=" + start + "&end=" + end +
                            "&metadata_query=" + encodeURIComponent("host=" + host) +
                            "&metadata_query=" + encodeURIComponent("tenant=" + tenant) +
                            "&metadata_query=" + encodeURIComponent("guid=All:"+eventType);
                    }
                }
            return endpoint;
        }

        function actViewKeyDown(evt) {
            evt = evt || window.event;
            const cctmodalElement = document.getElementById("cctpopup");

            if (cctmodalElement !== null && cctmodalElement.style.display !== "none") {
                console.log("cctpopup active " + clickC+ ":" +evt.keyCode);
                clickC++;
            }
        };

        $(function () {
            $(".img-swap").click(function () {
                if (compareTree) {
                    $(".img-swap").each(function () {
                        this.src = this.src.replace("_on", "_off");
                    });
                    this.src = this.src.replace("_off", "_on");
                    spinnerToggle('spinnerId');
                    prevOption = currentOption;
                    currentOption = Number($(this).attr('opt'));
                    updateProfilerView();
                    spinnerToggle('spinnerId');
                }
            });
        });

        function treeView(opt) {
            const tree = document.querySelectorAll('ul.tree div:not(:last-child)');
            for (let i = 0; i < tree.length; i++) {
                const parent = tree[i].parentElement;
                const classList = parent.classList;
                if (opt == 0) {
                    classList.add('open');
                } else {
                    classList.remove('open');
                }
            }
        }

        function openParent(p, t) {
            if (p.parentElement.classList.contains("tree")) {
                return;
            }
            p.parentElement.classList.add('open');
            openParent(p.parentElement, t);
        }

        function search() {
            initSearchTree(document.getElementById("search").value);
            let searchCount = 0;
            const tree = document.querySelectorAll('ul.tree span');
            for (let i = 0; i < tree.length; i++) {
                tree[i].classList.remove('sc');
                if (document.getElementById("search").value !== "" && tree[i].innerHTML.includes(document.getElementById("search").value)) {
                    searchCount++;
                    tree[i].classList.add('sc');
                    openParent(tree[i].parentElement, tree);
                }
            }
            $("span.cct-search-guid").html("<strong> Search found " + searchCount + " matching frame(s)</strong>");
        }

        function openUL(n) {
            const children = n.children;
            if (children.length == 1) {
                openNode(children[0]);
            }
        }

        function openNode(n) {
            const children = n.children;
            for (let i = 0; i < children.length; i++) {
                if (children[i].nodeName == 'UL') {
                    n.classList.add('open');
                    openUL(children[i]);
                }
            }
        }

        function addClickActionsToElement(element) {
            const tree = element.querySelectorAll('ul.tree div.subtree:not(:last-child)');
            for (let i = 0; i < tree.length; i++) {
                tree[i].addEventListener('click', function (e) {
                    const parent = $(e.target).closest("li")[0];
                    if(parent === undefined) {
                        return;
                    }
                    const classList = parent.classList;
                    if(classList.contains("expand")) {
                        classList.remove('expand');
                        expandTree(Number(parent.getAttribute('index')),parent)
                    }

                    if (classList.contains("open")) {
                        classList.remove('open');
                        const opensubs = parent.querySelectorAll(':scope .open');
                        for (let i = 0; i < opensubs.length; i++) {
                            opensubs[i].classList.remove('open');
                        }
                    } else {
                        if (e.altKey) {
                            classList.add('open');
                            const opensubs = parent.querySelectorAll('li');
                            for (let i = 0; i < opensubs.length; i++) {
                                opensubs[i].classList.add('open');
                            }
                        } else {
                            openNode(parent);
                        }
                    }
                });

                tree[i].addEventListener('contextmenu', function (e) {
                    e.preventDefault();
                    const parent = $(e.target).closest("li")[0];
                    const classList = parent.classList;
                    if(classList.contains("expand")) {
                        classList.remove('expand');
                        expandTree(Number(parent.getAttribute('index')),parent)
                    }
                    createCCTModal("cctpopup", parent.innerHTML);
                    loadCCTModal("cctpopup");
                    setTimeout(function () {
                        $('#cctpopup').focus();
                    }, 500);
                    return false;
                });
            }
        }

        function backtrace() {
            if (!isCalltree) {
                return;
            }
            updateUrl("isCalltree", false, true);
            isCalltree = false;

            if (getActiveTree(getEventType(), isCalltree) === undefined) {
                validateInputAndcreateContextTree(true);
            } else {
                updateProfilerView();
            }
        }

        function calltree() {
            if (isCalltree) {
                return;
            }
            updateUrl("isCalltree", true, true);
            isCalltree = true;
            if (getActiveTree(getEventType(), isCalltree) === undefined) {
                validateInputAndcreateContextTree(true);
            } else {
                updateProfilerView();
            }
        }

        function resetTreeHeader(msg) {
            $("span.cct-header-guid").html(msg);
            $("span.cct-search-guid").html("");
            $("ul.tree").html("");
        }

        function getTextForAggregationInput(tree) {
            let text = "<br><span>";
            // trim off prefix
            let metadata = tree["meta"];
            Object.keys(metadata).forEach(key => text += key.replace("aggregation-", "") + ": " + metadata[key] + "; ");
            text += "</span>";
            return text;
        }

        function isAggregation() {
            const urlParams = new URLSearchParams(location.href);
            return urlParams.get("is-aggregation") === "true";
        }

        function getTenantFromURL() {
            const urlParams = new URLSearchParams(location.href);
            let tenant = (urlParams.get("tenant"));
            return tenant ? tenant : ""; // return empty string when tenant is not set
        }

        function setAggregationFlag() {
            return "is-aggregation=true";
        }

            $( function() {
            $( "#accordion" ).accordion({
                collapsible: true,
                heightStyle: "content"
            });
        } );
        $( function() {
            $( "#contextfilter" ).accordion({
                collapsible: true
            });
        } );

    </script>
    <style>
        table, th, td {
            padding: 8px;
        }
        table {
            border-spacing: 30px;
        }
    </style>
</head>
<body>
<div id="header" style="height:50px; background-color: #429CD6">
    <h3  style="padding-left: 10px;color: white">Profile views</h3>
</div>
<#include "input.ftl">
<#include "filter-panel.ftl">
<#include "tabs.ftl">
</body>
</html>